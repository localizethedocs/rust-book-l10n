msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch10-03-lifetime-syntax.md:1
msgid "Validating References with Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:3
msgid ""
"Lifetimes are another kind of generic that we’ve already been using. Rather "
"than ensuring that a type has the behavior we want, lifetimes ensure that "
"references are valid as long as we need them to be."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:7
msgid ""
"One detail we didn’t discuss in the [“References and Borrowing”](ch04-02-"
"references-and-borrowing.html#references-and-borrowing)<!-- ignore --> "
"section in Chapter 4 is that every reference in Rust has a lifetime, which "
"is the scope for which that reference is valid. Most of the time, lifetimes "
"are implicit and inferred, just like most of the time, types are inferred. "
"We are only required to annotate types when multiple types are possible. In "
"a similar way, we must annotate lifetimes when the lifetimes of references "
"could be related in a few different ways. Rust requires us to annotate the "
"relationships using generic lifetime parameters to ensure that the actual "
"references used at runtime will definitely be valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:18
msgid ""
"Annotating lifetimes is not even a concept most other programming languages "
"have, so this is going to feel unfamiliar. Although we won’t cover lifetimes "
"in their entirety in this chapter, we’ll discuss common ways you might "
"encounter lifetime syntax so that you can get comfortable with the concept."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:25
msgid "<a id=\"preventing-dangling-references-with-lifetimes\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:27
msgid "Dangling References"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:29
msgid ""
"The main aim of lifetimes is to prevent dangling references, which, if they "
"were allowed to exist, would cause a program to reference data other than "
"the data it’s intended to reference. Consider the program in Listing 10-16, "
"which has an outer scope and an inner scope."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:45 src/ch10-03-lifetime-syntax.md:110
#: src/ch10-03-lifetime-syntax.md:134
msgid "\"r: {r}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:51
msgid ""
"Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables "
"without giving them an initial value, so the variable name exists in the "
"outer scope. At first glance, this might appear to be in conflict with Rust "
"having no null values. However, if we try to use a variable before giving it "
"a value, we’ll get a compile-time error, which shows that indeed Rust does "
"not allow null values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:58
msgid ""
"The outer scope declares a variable named `r` with no initial value, and the "
"inner scope declares a variable named `x` with the initial value of `5`. "
"Inside the inner scope, we attempt to set the value of `r` as a reference to "
"`x`. Then, the inner scope ends, and we attempt to print the value in `r`. "
"This code won’t compile, because the value that `r` is referring to has gone "
"out of scope before we try to use it. Here is the error message:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:65
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `x` does not live long enough\n"
" --> src/main.rs:6:13\n"
"  |\n"
"5 |         let x = 5;\n"
"  |             - binding `x` declared here\n"
"6 |         r = &x;\n"
"  |             ^^ borrowed value does not live long enough\n"
"7 |     }\n"
"  |     - `x` dropped here while still borrowed\n"
"8 |\n"
"9 |     println!(\"r: {r}\");\n"
"  |                   - borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:85
msgid ""
"The error message says that the variable `x` “does not live long enough.” "
"The reason is that `x` will be out of scope when the inner scope ends on "
"line 7. But `r` is still valid for the outer scope; because its scope is "
"larger, we say that it “lives longer.” If Rust allowed this code to work, "
"`r` would be referencing memory that was deallocated when `x` went out of "
"scope, and anything we tried to do with `r` wouldn’t work correctly. So, how "
"does Rust determine that this code is invalid? It uses a borrow checker."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:93
msgid "The Borrow Checker"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:95
msgid ""
"The Rust compiler has a _borrow checker_ that compares scopes to determine "
"whether all borrows are valid. Listing 10-17 shows the same code as Listing "
"10-16 but with annotations showing the lifetimes of the variables."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:103
msgid ""
"// ---------+-- 'a\n"
"                          //          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:105 src/ch10-03-lifetime-syntax.md:110
msgid "//          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:106
msgid "// -+-- 'b  |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:107
msgid "//  |       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:108
msgid ""
"// -+       |\n"
"                          //          |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:111
msgid "// ---------+\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:116
msgid ""
"Here, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x` "
"with `'b`. As you can see, the inner `'b` block is much smaller than the "
"outer `'a` lifetime block. At compile time, Rust compares the size of the "
"two lifetimes and sees that `r` has a lifetime of `'a` but that it refers to "
"memory with a lifetime of `'b`. The program is rejected because `'b` is "
"shorter than `'a`: The subject of the reference doesn’t live as long as the "
"reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:123
msgid ""
"Listing 10-18 fixes the code so that it doesn’t have a dangling reference "
"and it compiles without any errors."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:130
msgid ""
"// ----------+-- 'b\n"
"                          //           |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:132
msgid ""
"// --+-- 'a  |\n"
"                          //   |       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:134
msgid ""
"//   |       |\n"
"                          // --+       |\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:136
msgid "// ----------+\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:141
msgid ""
"Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. "
"This means `r` can reference `x` because Rust knows that the reference in "
"`r` will always be valid while `x` is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:145
msgid ""
"Now that you know where the lifetimes of references are and how Rust "
"analyzes lifetimes to ensure that references will always be valid, let’s "
"explore generic lifetimes in function parameters and return values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:149
msgid "Generic Lifetimes in Functions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:151
msgid ""
"We’ll write a function that returns the longer of two string slices. This "
"function will take two string slices and return a single string slice. After "
"we’ve implemented the `longest` function, the code in Listing 10-19 should "
"print `The longest string is abcd`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:160 src/ch10-03-lifetime-syntax.md:184
#: src/ch10-03-lifetime-syntax.md:285 src/ch10-03-lifetime-syntax.md:451
#: src/ch10-03-lifetime-syntax.md:481 src/ch10-03-lifetime-syntax.md:846
msgid "\"abcd\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:161 src/ch10-03-lifetime-syntax.md:185
#: src/ch10-03-lifetime-syntax.md:286 src/ch10-03-lifetime-syntax.md:348
#: src/ch10-03-lifetime-syntax.md:382 src/ch10-03-lifetime-syntax.md:482
#: src/ch10-03-lifetime-syntax.md:847
msgid "\"xyz\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:164 src/ch10-03-lifetime-syntax.md:188
#: src/ch10-03-lifetime-syntax.md:289 src/ch10-03-lifetime-syntax.md:350
#: src/ch10-03-lifetime-syntax.md:385 src/ch10-03-lifetime-syntax.md:455
#: src/ch10-03-lifetime-syntax.md:485 src/ch10-03-lifetime-syntax.md:854
msgid "\"The longest string is {result}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:170
msgid ""
"Note that we want the function to take string slices, which are references, "
"rather than strings, because we don’t want the `longest` function to take "
"ownership of its parameters. Refer to [“String Slices as Parameters”]"
"(ch04-03-slices.html#string-slices-as-parameters)<!-- ignore --> in Chapter "
"4 for more discussion about why the parameters we use in Listing 10-19 are "
"the ones we want."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:177
msgid ""
"If we try to implement the `longest` function as shown in Listing 10-20, it "
"won’t compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:198
msgid "Instead, we get the following error that talks about lifetimes:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:200
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:9:33\n"
"  |\n"
"9 | fn longest(x: &str, y: &str) -> &str {\n"
"  |               ----     ----     ^ expected named lifetime parameter\n"
"  |\n"
"  = help: this function's return type contains a borrowed value, but the "
"signature does not say whether it is borrowed from `x` or `y`\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n"
"  |           ++++     ++          ++          ++\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:219
msgid ""
"The help text reveals that the return type needs a generic lifetime "
"parameter on it because Rust can’t tell whether the reference being returned "
"refers to `x` or `y`. Actually, we don’t know either, because the `if` block "
"in the body of this function returns a reference to `x` and the `else` block "
"returns a reference to `y`!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:225
msgid ""
"When we’re defining this function, we don’t know the concrete values that "
"will be passed into this function, so we don’t know whether the `if` case or "
"the `else` case will execute. We also don’t know the concrete lifetimes of "
"the references that will be passed in, so we can’t look at the scopes as we "
"did in Listings 10-17 and 10-18 to determine whether the reference we return "
"will always be valid. The borrow checker can’t determine this either, "
"because it doesn’t know how the lifetimes of `x` and `y` relate to the "
"lifetime of the return value. To fix this error, we’ll add generic lifetime "
"parameters that define the relationship between the references so that the "
"borrow checker can perform its analysis."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:236
msgid "Lifetime Annotation Syntax"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:238
msgid ""
"Lifetime annotations don’t change how long any of the references live. "
"Rather, they describe the relationships of the lifetimes of multiple "
"references to each other without affecting the lifetimes. Just as functions "
"can accept any type when the signature specifies a generic type parameter, "
"functions can accept references with any lifetime by specifying a generic "
"lifetime parameter."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:244
msgid ""
"Lifetime annotations have a slightly unusual syntax: The names of lifetime "
"parameters must start with an apostrophe (`'`) and are usually all lowercase "
"and very short, like generic types. Most people use the name `'a` for the "
"first lifetime annotation. We place lifetime parameter annotations after the "
"`&` of a reference, using a space to separate the annotation from the "
"reference’s type."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:250
msgid ""
"Here are some examples—a reference to an `i32` without a lifetime parameter, "
"a reference to an `i32` that has a lifetime parameter named `'a`, and a "
"mutable reference to an `i32` that also has the lifetime `'a`:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:255
msgid "// a reference\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:256
msgid "// a reference with an explicit lifetime\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:257
msgid "// a mutable reference with an explicit lifetime\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:260
msgid ""
"One lifetime annotation by itself doesn’t have much meaning, because the "
"annotations are meant to tell Rust how generic lifetime parameters of "
"multiple references relate to each other. Let’s examine how the lifetime "
"annotations relate to each other in the context of the `longest` function."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:267
msgid "<a id=\"lifetime-annotations-in-function-signatures\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:269
msgid "In Function Signatures"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:271
msgid ""
"To use lifetime annotations in function signatures, we need to declare the "
"generic lifetime parameters inside angle brackets between the function name "
"and the parameter list, just as we did with generic type parameters."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:275
msgid ""
"We want the signature to express the following constraint: The returned "
"reference will be valid as long as both of the parameters are valid. This is "
"the relationship between lifetimes of the parameters and the return value. "
"We’ll name the lifetime `'a` and then add it to each reference, as shown in "
"Listing 10-21."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:299
msgid ""
"This code should compile and produce the result we want when we use it with "
"the `main` function in Listing 10-19."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:302
msgid ""
"The function signature now tells Rust that for some lifetime `'a`, the "
"function takes two parameters, both of which are string slices that live at "
"least as long as lifetime `'a`. The function signature also tells Rust that "
"the string slice returned from the function will live at least as long as "
"lifetime `'a`. In practice, it means that the lifetime of the reference "
"returned by the `longest` function is the same as the smaller of the "
"lifetimes of the values referred to by the function arguments. These "
"relationships are what we want Rust to use when analyzing this code."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:311
msgid ""
"Remember, when we specify the lifetime parameters in this function "
"signature, we’re not changing the lifetimes of any values passed in or "
"returned. Rather, we’re specifying that the borrow checker should reject any "
"values that don’t adhere to these constraints. Note that the `longest` "
"function doesn’t need to know exactly how long `x` and `y` will live, only "
"that some scope can be substituted for `'a` that will satisfy this signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:318
msgid ""
"When annotating lifetimes in functions, the annotations go in the function "
"signature, not in the function body. The lifetime annotations become part of "
"the contract of the function, much like the types in the signature. Having "
"function signatures contain the lifetime contract means the analysis the "
"Rust compiler does can be simpler. If there’s a problem with the way a "
"function is annotated or the way it is called, the compiler errors can point "
"to the part of our code and the constraints more precisely. If, instead, the "
"Rust compiler made more inferences about what we intended the relationships "
"of the lifetimes to be, the compiler might only be able to point to a use of "
"our code many steps away from the cause of the problem."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:329
msgid ""
"When we pass concrete references to `longest`, the concrete lifetime that is "
"substituted for `'a` is the part of the scope of `x` that overlaps with the "
"scope of `y`. In other words, the generic lifetime `'a` will get the "
"concrete lifetime that is equal to the smaller of the lifetimes of `x` and "
"`y`. Because we’ve annotated the returned reference with the same lifetime "
"parameter `'a`, the returned reference will also be valid for the length of "
"the smaller of the lifetimes of `x` and `y`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:337
msgid ""
"Let’s look at how the lifetime annotations restrict the `longest` function "
"by passing in references that have different concrete lifetimes. Listing "
"10-22 is a straightforward example."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:345 src/ch10-03-lifetime-syntax.md:379
msgid "\"long string is long\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:361
msgid ""
"In this example, `string1` is valid until the end of the outer scope, "
"`string2` is valid until the end of the inner scope, and `result` references "
"something that is valid until the end of the inner scope. Run this code and "
"you’ll see that the borrow checker approves; it will compile and print `The "
"longest string is long string is long`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:367
msgid ""
"Next, let’s try an example that shows that the lifetime of the reference in "
"`result` must be the smaller lifetime of the two arguments. We’ll move the "
"declaration of the `result` variable outside the inner scope but leave the "
"assignment of the value to the `result` variable inside the scope with "
"`string2`. Then, we’ll move the `println!` that uses `result` to outside the "
"inner scope, after the inner scope has ended. The code in Listing 10-23 will "
"not compile."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:395
msgid "When we try to compile this code, we get this error:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:397
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0597]: `string2` does not live long enough\n"
" --> src/main.rs:6:44\n"
"  |\n"
"5 |         let string2 = String::from(\"xyz\");\n"
"  |             ------- binding `string2` declared here\n"
"6 |         result = longest(string1.as_str(), string2.as_str());\n"
"  |                                            ^^^^^^^ borrowed value does "
"not live long enough\n"
"7 |     }\n"
"  |     - `string2` dropped here while still borrowed\n"
"8 |     println!(\"The longest string is {result}\");\n"
"  |                                      ------ borrow later used here\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:416
msgid ""
"The error shows that for `result` to be valid for the `println!` statement, "
"`string2` would need to be valid until the end of the outer scope. Rust "
"knows this because we annotated the lifetimes of the function parameters and "
"return values using the same lifetime parameter `'a`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:421
msgid ""
"As humans, we can look at this code and see that `string1` is longer than "
"`string2`, and therefore, `result` will contain a reference to `string1`. "
"Because `string1` has not gone out of scope yet, a reference to `string1` "
"will still be valid for the `println!` statement. However, the compiler "
"can’t see that the reference is valid in this case. We’ve told Rust that the "
"lifetime of the reference returned by the `longest` function is the same as "
"the smaller of the lifetimes of the references passed in. Therefore, the "
"borrow checker disallows the code in Listing 10-23 as possibly having an "
"invalid reference."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:430
msgid ""
"Try designing more experiments that vary the values and lifetimes of the "
"references passed in to the `longest` function and how the returned "
"reference is used. Make hypotheses about whether or not your experiments "
"will pass the borrow checker before you compile; then, check to see if "
"you’re right!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:437
msgid "<a id=\"thinking-in-terms-of-lifetimes\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:439
msgid "Relationships"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:441
msgid ""
"The way in which you need to specify lifetime parameters depends on what "
"your function is doing. For example, if we changed the implementation of the "
"`longest` function to always return the first parameter rather than the "
"longest string slice, we wouldn’t need to specify a lifetime on the `y` "
"parameter. The following code will compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:452
msgid "\"efghijklmnopqrstuvwxyz\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:465
msgid ""
"We’ve specified a lifetime parameter `'a` for the parameter `x` and the "
"return type, but not for the parameter `y`, because the lifetime of `y` does "
"not have any relationship with the lifetime of `x` or the return value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:469
msgid ""
"When returning a reference from a function, the lifetime parameter for the "
"return type needs to match the lifetime parameter for one of the parameters. "
"If the reference returned does _not_ refer to one of the parameters, it must "
"refer to a value created within this function. However, this would be a "
"dangling reference because the value will go out of scope at the end of the "
"function. Consider this attempted implementation of the `longest` function "
"that won’t compile:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:489
msgid "\"really long string\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:496
msgid ""
"Here, even though we’ve specified a lifetime parameter `'a` for the return "
"type, this implementation will fail to compile because the return value "
"lifetime is not related to the lifetime of the parameters at all. Here is "
"the error message we get:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:501
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\n"
"error[E0515]: cannot return value referencing local variable `result`\n"
"  --> src/main.rs:11:5\n"
"   |\n"
"11 |     result.as_str()\n"
"   |     ------^^^^^^^^^\n"
"   |     |\n"
"   |     returns a value referencing data owned by the current function\n"
"   |     `result` is borrowed here\n"
"\n"
"For more information about this error, try `rustc --explain E0515`.\n"
"error: could not compile `chapter10` (bin \"chapter10\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:517
msgid ""
"The problem is that `result` goes out of scope and gets cleaned up at the "
"end of the `longest` function. We’re also trying to return a reference to "
"`result` from the function. There is no way we can specify lifetime "
"parameters that would change the dangling reference, and Rust won’t let us "
"create a dangling reference. In this case, the best fix would be to return "
"an owned data type rather than a reference so that the calling function is "
"then responsible for cleaning up the value."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:525
msgid ""
"Ultimately, lifetime syntax is about connecting the lifetimes of various "
"parameters and return values of functions. Once they’re connected, Rust has "
"enough information to allow memory-safe operations and disallow operations "
"that would create dangling pointers or otherwise violate memory safety."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:532
msgid "<a id=\"lifetime-annotations-in-struct-definitions\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:534
msgid "In Struct Definitions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:536
msgid ""
"So far, the structs we’ve defined all hold owned types. We can define "
"structs to hold references, but in that case, we would need to add a "
"lifetime annotation on every reference in the struct’s definition. Listing "
"10-24 has a struct named `ImportantExcerpt` that holds a string slice."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:549 src/ch10-03-lifetime-syntax.md:768
#: src/ch10-03-lifetime-syntax.md:801
msgid "\"Call me Ishmael. Some years ago...\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:550 src/ch10-03-lifetime-syntax.md:769
#: src/ch10-03-lifetime-syntax.md:802
msgid "'.'"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:559
msgid ""
"This struct has the single field `part` that holds a string slice, which is "
"a reference. As with generic data types, we declare the name of the generic "
"lifetime parameter inside angle brackets after the name of the struct so "
"that we can use the lifetime parameter in the body of the struct definition. "
"This annotation means an instance of `ImportantExcerpt` can’t outlive the "
"reference it holds in its `part` field."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:566
msgid ""
"The `main` function here creates an instance of the `ImportantExcerpt` "
"struct that holds a reference to the first sentence of the `String` owned by "
"the variable `novel`. The data in `novel` exists before the "
"`ImportantExcerpt` instance is created. In addition, `novel` doesn’t go out "
"of scope until after the `ImportantExcerpt` goes out of scope, so the "
"reference in the `ImportantExcerpt` instance is valid."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:573
msgid "Lifetime Elision"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:575
msgid ""
"You’ve learned that every reference has a lifetime and that you need to "
"specify lifetime parameters for functions or structs that use references. "
"However, we had a function in Listing 4-9, shown again in Listing 10-25, "
"that compiled without lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:587
msgid "b' '"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:596 src/ch10-03-lifetime-syntax.md:601
msgid "\"hello world\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:598
msgid "// first_word works on slices of `String`s\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:603
msgid "// first_word works on slices of string literals\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:606
msgid "// Because string literals *are* string slices already,\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:607
msgid "// this works too, without the slice syntax!\n"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:614
msgid ""
"The reason this function compiles without lifetime annotations is "
"historical: In early versions (pre-1.0) of Rust, this code wouldn’t have "
"compiled, because every reference needed an explicit lifetime. At that time, "
"the function signature would have been written like this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:623
msgid ""
"After writing a lot of Rust code, the Rust team found that Rust programmers "
"were entering the same lifetime annotations over and over in particular "
"situations. These situations were predictable and followed a few "
"deterministic patterns. The developers programmed these patterns into the "
"compiler’s code so that the borrow checker could infer the lifetimes in "
"these situations and wouldn’t need explicit annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:630
msgid ""
"This piece of Rust history is relevant because it’s possible that more "
"deterministic patterns will emerge and be added to the compiler. In the "
"future, even fewer lifetime annotations might be required."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:634
msgid ""
"The patterns programmed into Rust’s analysis of references are called the "
"_lifetime elision rules_. These aren’t rules for programmers to follow; "
"they’re a set of particular cases that the compiler will consider, and if "
"your code fits these cases, you don’t need to write the lifetimes explicitly."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:639
msgid ""
"The elision rules don’t provide full inference. If there is still ambiguity "
"about what lifetimes the references have after Rust applies the rules, the "
"compiler won’t guess what the lifetime of the remaining references should "
"be. Instead of guessing, the compiler will give you an error that you can "
"resolve by adding the lifetime annotations."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:645
msgid ""
"Lifetimes on function or method parameters are called _input lifetimes_, and "
"lifetimes on return values are called _output lifetimes_."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:648
msgid ""
"The compiler uses three rules to figure out the lifetimes of the references "
"when there aren’t explicit annotations. The first rule applies to input "
"lifetimes, and the second and third rules apply to output lifetimes. If the "
"compiler gets to the end of the three rules and there are still references "
"for which it can’t figure out lifetimes, the compiler will stop with an "
"error. These rules apply to `fn` definitions as well as `impl` blocks."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:655
msgid ""
"The first rule is that the compiler assigns a lifetime parameter to each "
"parameter that’s a reference. In other words, a function with one parameter "
"gets one lifetime parameter: `fn foo<'a>(x: &'a i32)`; a function with two "
"parameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a "
"i32, y: &'b i32)`; and so on."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:661
msgid ""
"The second rule is that, if there is exactly one input lifetime parameter, "
"that lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: "
"&'a i32) -> &'a i32`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:665
msgid ""
"The third rule is that, if there are multiple input lifetime parameters, but "
"one of them is `&self` or `&mut self` because this is a method, the lifetime "
"of `self` is assigned to all output lifetime parameters. This third rule "
"makes methods much nicer to read and write because fewer symbols are "
"necessary."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:670
msgid ""
"Let’s pretend we’re the compiler. We’ll apply these rules to figure out the "
"lifetimes of the references in the signature of the `first_word` function in "
"Listing 10-25. The signature starts without any lifetimes associated with "
"the references:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:679
msgid ""
"Then, the compiler applies the first rule, which specifies that each "
"parameter gets its own lifetime. We’ll call it `'a` as usual, so now the "
"signature is this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:687
msgid ""
"The second rule applies because there is exactly one input lifetime. The "
"second rule specifies that the lifetime of the one input parameter gets "
"assigned to the output lifetime, so the signature is now this:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:695
msgid ""
"Now all the references in this function signature have lifetimes, and the "
"compiler can continue its analysis without needing the programmer to "
"annotate the lifetimes in this function signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:699
msgid ""
"Let’s look at another example, this time using the `longest` function that "
"had no lifetime parameters when we started working with it in Listing 10-20:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:706
msgid ""
"Let’s apply the first rule: Each parameter gets its own lifetime. This time "
"we have two parameters instead of one, so we have two lifetimes:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:713
msgid ""
"You can see that the second rule doesn’t apply, because there is more than "
"one input lifetime. The third rule doesn’t apply either, because `longest` "
"is a function rather than a method, so none of the parameters are `self`. "
"After working through all three rules, we still haven’t figured out what the "
"return type’s lifetime is. This is why we got an error trying to compile the "
"code in Listing 10-20: The compiler worked through the lifetime elision "
"rules but still couldn’t figure out all the lifetimes of the references in "
"the signature."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:721
msgid ""
"Because the third rule really only applies in method signatures, we’ll look "
"at lifetimes in that context next to see why the third rule means we don’t "
"have to annotate lifetimes in method signatures very often."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:727
msgid "<a id=\"lifetime-annotations-in-method-definitions\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:729
msgid "In Method Definitions"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:731
msgid ""
"When we implement methods on a struct with lifetimes, we use the same syntax "
"as that of generic type parameters, as shown in Listing 10-11. Where we "
"declare and use the lifetime parameters depends on whether they’re related "
"to the struct fields or the method parameters and return values."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:736
msgid ""
"Lifetime names for struct fields always need to be declared after the `impl` "
"keyword and then used after the struct’s name because those lifetimes are "
"part of the struct’s type."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:740
msgid ""
"In method signatures inside the `impl` block, references might be tied to "
"the lifetime of references in the struct’s fields, or they might be "
"independent. In addition, the lifetime elision rules often make it so that "
"lifetime annotations aren’t necessary in method signatures. Let’s look at "
"some examples using the struct named `ImportantExcerpt` that we defined in "
"Listing 10-24."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:746
msgid ""
"First, we’ll use a method named `level` whose only parameter is a reference "
"to `self` and whose return value is an `i32`, which is not a reference to "
"anything:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:762 src/ch10-03-lifetime-syntax.md:795
msgid "\"Attention please: {announcement}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:776
msgid ""
"The lifetime parameter declaration after `impl` and its use after the type "
"name are required, but because of the first elision rule, we’re not required "
"to annotate the lifetime of the reference to `self`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:780
msgid "Here is an example where the third lifetime elision rule applies:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:809
msgid ""
"There are two input lifetimes, so Rust applies the first lifetime elision "
"rule and gives both `&self` and `announcement` their own lifetimes. Then, "
"because one of the parameters is `&self`, the return type gets the lifetime "
"of `&self`, and all lifetimes have been accounted for."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:814
msgid "The Static Lifetime"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:816
msgid ""
"One special lifetime we need to discuss is `'static`, which denotes that the "
"affected reference _can_ live for the entire duration of the program. All "
"string literals have the `'static` lifetime, which we can annotate as "
"follows:"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:821
msgid "\"I have a static lifetime.\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:824
msgid ""
"The text of this string is stored directly in the program’s binary, which is "
"always available. Therefore, the lifetime of all string literals is "
"`'static`."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:827
msgid ""
"You might see suggestions in error messages to use the `'static` lifetime. "
"But before specifying `'static` as the lifetime for a reference, think about "
"whether or not the reference you have actually lives the entire lifetime of "
"your program, and whether you want it to. Most of the time, an error message "
"suggesting the `'static` lifetime results from attempting to create a "
"dangling reference or a mismatch of the available lifetimes. In such cases, "
"the solution is to fix those problems, not to specify the `'static` lifetime."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:837
msgid ""
"<a id=\"generic-type-parameters-trait-bounds-and-lifetimes-together\"></a>"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:839
msgid "Generic Type Parameters, Trait Bounds, and Lifetimes"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:841
msgid ""
"Let’s briefly look at the syntax of specifying generic type parameters, "
"trait bounds, and lifetimes all in one function!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:852
msgid "\"Today is someone's birthday!\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:867
msgid "\"Announcement! {ann}\""
msgstr ""

#: src/ch10-03-lifetime-syntax.md:872
msgid ""
"This is the `longest` function from Listing 10-21 that returns the longer of "
"two string slices. But now it has an extra parameter named `ann` of the "
"generic type `T`, which can be filled in by any type that implements the "
"`Display` trait as specified by the `where` clause. This extra parameter "
"will be printed using `{}`, which is why the `Display` trait bound is "
"necessary. Because lifetimes are a type of generic, the declarations of the "
"lifetime parameter `'a` and the generic type parameter `T` go in the same "
"list inside the angle brackets after the function name."
msgstr ""

#: src/ch10-03-lifetime-syntax.md:881
msgid "Summary"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:883
msgid ""
"We covered a lot in this chapter! Now that you know about generic type "
"parameters, traits and trait bounds, and generic lifetime parameters, you’re "
"ready to write code without repetition that works in many different "
"situations. Generic type parameters let you apply the code to different "
"types. Traits and trait bounds ensure that even though the types are "
"generic, they’ll have the behavior the code needs. You learned how to use "
"lifetime annotations to ensure that this flexible code won’t have any "
"dangling references. And all of this analysis happens at compile time, which "
"doesn’t affect runtime performance!"
msgstr ""

#: src/ch10-03-lifetime-syntax.md:892
msgid ""
"Believe it or not, there is much more to learn on the topics we discussed in "
"this chapter: Chapter 18 discusses trait objects, which are another way to "
"use traits. There are also more complex scenarios involving lifetime "
"annotations that you will only need in very advanced scenarios; for those, "
"you should read the [Rust Reference](../reference/trait-bounds.html). But "
"next, you’ll learn how to write tests in Rust so that you can make sure your "
"code is working the way it should."
msgstr ""
