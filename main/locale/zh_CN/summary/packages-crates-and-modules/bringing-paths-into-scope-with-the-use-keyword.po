msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:1
msgid "Bringing Paths into Scope with the `use` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:3
msgid ""
"Having to write out the paths to call functions can feel inconvenient and "
"repetitive. In Listing 7-7, whether we chose the absolute or relative path "
"to the `add_to_waitlist` function, every time we wanted to call "
"`add_to_waitlist` we had to specify `front_of_house` and `hosting` too. "
"Fortunately, there’s a way to simplify this process: We can create a "
"shortcut to a path with the `use` keyword once and then use the shorter name "
"everywhere else in the scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:10
msgid ""
"In Listing 7-11, we bring the `crate::front_of_house::hosting` module into "
"the scope of the `eat_at_restaurant` function so that we only have to "
"specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in "
"`eat_at_restaurant`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:33
msgid ""
"Adding `use` and a path in a scope is similar to creating a symbolic link in "
"the filesystem. By adding `use crate::front_of_house::hosting` in the crate "
"root, `hosting` is now a valid name in that scope, just as though the "
"`hosting` module had been defined in the crate root. Paths brought into "
"scope with `use` also check privacy, like any other paths."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:39
msgid ""
"Note that `use` only creates the shortcut for the particular scope in which "
"the `use` occurs. Listing 7-12 moves the `eat_at_restaurant` function into a "
"new child module named `customer`, which is then a different scope than the "
"`use` statement, so the function body won’t compile."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:64
msgid ""
"The compiler error shows that the shortcut no longer applies within the "
"`customer` module:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:67
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling restaurant v0.1.0 (file:///projects/restaurant)\n"
"error[E0433]: failed to resolve: use of unresolved module or unlinked crate "
"`hosting`\n"
"  --> src/lib.rs:11:9\n"
"   |\n"
"11 |         hosting::add_to_waitlist();\n"
"   |         ^^^^^^^ use of unresolved module or unlinked crate `hosting`\n"
"   |\n"
"   = help: if you wanted to use a crate named `hosting`, use `cargo add "
"hosting` to add it to your `Cargo.toml`\n"
"help: consider importing this module through its public re-export\n"
"   |\n"
"10 +     use crate::hosting;\n"
"   |\n"
"\n"
"warning: unused import: `crate::front_of_house::hosting`\n"
" --> src/lib.rs:7:5\n"
"  |\n"
"7 | use crate::front_of_house::hosting;\n"
"  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  |\n"
"  = note: `#[warn(unused_imports)]` on by default\n"
"\n"
"For more information about this error, try `rustc --explain E0433`.\n"
"warning: `restaurant` (lib) generated 1 warning\n"
"error: could not compile `restaurant` (lib) due to 1 previous error; 1 "
"warning emitted\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:95
msgid ""
"Notice there’s also a warning that the `use` is no longer used in its scope! "
"To fix this problem, move the `use` within the `customer` module too, or "
"reference the shortcut in the parent module with `super::hosting` within the "
"child `customer` module."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:100
msgid "Creating Idiomatic `use` Paths"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:102
msgid ""
"In Listing 7-11, you might have wondered why we specified `use crate::"
"front_of_house::hosting` and then called `hosting::add_to_waitlist` in "
"`eat_at_restaurant`, rather than specifying the `use` path all the way out "
"to the `add_to_waitlist` function to achieve the same result, as in Listing "
"7-13."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:125
msgid ""
"Although both Listing 7-11 and Listing 7-13 accomplish the same task, "
"Listing 7-11 is the idiomatic way to bring a function into scope with `use`. "
"Bringing the function’s parent module into scope with `use` means we have to "
"specify the parent module when calling the function. Specifying the parent "
"module when calling the function makes it clear that the function isn’t "
"locally defined while still minimizing repetition of the full path. The code "
"in Listing 7-13 is unclear as to where `add_to_waitlist` is defined."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:133
msgid ""
"On the other hand, when bringing in structs, enums, and other items with "
"`use`, it’s idiomatic to specify the full path. Listing 7-14 shows the "
"idiomatic way to bring the standard library’s `HashMap` struct into the "
"scope of a binary crate."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:151
msgid ""
"There’s no strong reason behind this idiom: It’s just the convention that "
"has emerged, and folks have gotten used to reading and writing Rust code "
"this way."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:154
msgid ""
"The exception to this idiom is if we’re bringing two items with the same "
"name into scope with `use` statements, because Rust doesn’t allow that. "
"Listing 7-15 shows how to bring two `Result` types into scope that have the "
"same name but different parent modules, and how to refer to them."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:166
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:171
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:197
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:202
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:348
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:351
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:389
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:391
msgid "// --snip--\n"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:178
msgid ""
"As you can see, using the parent modules distinguishes the two `Result` "
"types. If instead we specified `use std::fmt::Result` and `use std::io::"
"Result`, we’d have two `Result` types in the same scope, and Rust wouldn’t "
"know which one we meant when we used `Result`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:183
msgid "Providing New Names with the `as` Keyword"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:185
msgid ""
"There’s another solution to the problem of bringing two types of the same "
"name into the same scope with `use`: After the path, we can specify `as` and "
"a new local name, or _alias_, for the type. Listing 7-16 shows another way "
"to write the code in Listing 7-15 by renaming one of the two `Result` types "
"using `as`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:209
msgid ""
"In the second `use` statement, we chose the new name `IoResult` for the "
"`std::io::Result` type, which won’t conflict with the `Result` from `std::"
"fmt` that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are "
"considered idiomatic, so the choice is up to you!"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:214
msgid "Re-exporting Names with `pub use`"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:216
msgid ""
"When we bring a name into scope with the `use` keyword, the name is private "
"to the scope into which we imported it. To enable code outside that scope to "
"refer to that name as if it had been defined in that scope, we can combine "
"`pub` and `use`. This technique is called _re-exporting_ because we’re "
"bringing an item into scope but also making that item available for others "
"to bring into their scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:223
msgid ""
"Listing 7-17 shows the code in Listing 7-11 with `use` in the root module "
"changed to `pub use`."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:244
msgid ""
"Before this change, external code would have to call the `add_to_waitlist` "
"function by using the path `restaurant::front_of_house::hosting::"
"add_to_waitlist()`, which also would have required the `front_of_house` "
"module to be marked as `pub`. Now that this `pub use` has re-exported the "
"`hosting` module from the root module, external code can use the path "
"`restaurant::hosting::add_to_waitlist()` instead."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:251
msgid ""
"Re-exporting is useful when the internal structure of your code is different "
"from how programmers calling your code would think about the domain. For "
"example, in this restaurant metaphor, the people running the restaurant "
"think about “front of house” and “back of house.” But customers visiting a "
"restaurant probably won’t think about the parts of the restaurant in those "
"terms. With `pub use`, we can write our code with one structure but expose a "
"different structure. Doing so makes our library well organized for "
"programmers working on the library and programmers calling the library. "
"We’ll look at another example of `pub use` and how it affects your crate’s "
"documentation in [“Exporting a Convenient Public API”](ch14-02-publishing-to-"
"crates-io.html#exporting-a-convenient-public-api)<!-- ignore --> in Chapter "
"14."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:262
msgid "Using External Packages"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:264
msgid ""
"In Chapter 2, we programmed a guessing game project that used an external "
"package called `rand` to get random numbers. To use `rand` in our project, "
"we added this line to _Cargo.toml_:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:276
msgid ""
"```toml\n"
"rand = \"0.8.5\"\n"
"```"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:282
msgid ""
"Adding `rand` as a dependency in _Cargo.toml_ tells Cargo to download the "
"`rand` package and any dependencies from [crates.io](https://crates.io/) and "
"make `rand` available to our project."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:286
msgid ""
"Then, to bring `rand` definitions into the scope of our package, we added a "
"`use` line starting with the name of the crate, `rand`, and listed the items "
"we wanted to bring into scope. Recall that in [“Generating a Random Number”]"
"(ch02-00-guessing-game-tutorial.html#generating-a-random-number)<!-- ignore "
"--> in Chapter 2, we brought the `Rng` trait into scope and called the "
"`rand::thread_rng` function:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:298
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:355
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:395
msgid "\"Guess the number!\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:302
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:359
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:399
msgid "\"The secret number is: {secret_number}\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:304
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:361
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:401
msgid "\"Please input your guess.\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:310
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:367
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:407
msgid "\"Failed to read line\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:312
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:369
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:411
msgid "\"You guessed: {guess}\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:316
msgid ""
"Members of the Rust community have made many packages available at [crates."
"io](https://crates.io/), and pulling any of them into your package involves "
"these same steps: listing them in your package’s _Cargo.toml_ file and using "
"`use` to bring items from their crates into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:321
msgid ""
"Note that the standard `std` library is also a crate that’s external to our "
"package. Because the standard library is shipped with the Rust language, we "
"don’t need to change _Cargo.toml_ to include `std`. But we do need to refer "
"to it with `use` to bring items from there into our package’s scope. For "
"example, with `HashMap` we would use this line:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:331
msgid ""
"This is an absolute path starting with `std`, the name of the standard "
"library crate."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:336
msgid "<a id=\"using-nested-paths-to-clean-up-large-use-lists\"></a>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:338
msgid "Using Nested Paths to Clean Up `use` Lists"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:340
msgid ""
"If we’re using multiple items defined in the same crate or same module, "
"listing each item on its own line can take up a lot of vertical space in our "
"files. For example, these two `use` statements we had in the guessing game "
"in Listing 2-4 bring items from `std` into scope:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:372
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:414
msgid "\"Too small!\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:373
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:415
msgid "\"Too big!\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:374
#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:416
msgid "\"You win!\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:381
msgid ""
"Instead, we can use nested paths to bring the same items into scope in one "
"line. We do this by specifying the common part of the path, followed by two "
"colons, and then curly brackets around a list of the parts of the paths that "
"differ, as shown in Listing 7-18."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:409
msgid "\"Please type a number!\""
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:423
msgid ""
"In bigger programs, bringing many items into scope from the same crate or "
"module using nested paths can reduce the number of separate `use` statements "
"needed by a lot!"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:427
msgid ""
"We can use a nested path at any level in a path, which is useful when "
"combining two `use` statements that share a subpath. For example, Listing "
"7-19 shows two `use` statements: one that brings `std::io` into scope and "
"one that brings `std::io::Write` into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:441
msgid ""
"The common part of these two paths is `std::io`, and that’s the complete "
"first path. To merge these two paths into one `use` statement, we can use "
"`self` in the nested path, as shown in Listing 7-20."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:453
msgid "This line brings `std::io` and `std::io::Write` into scope."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:457
msgid "<a id=\"the-glob-operator\"></a>"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:459
msgid "Importing Items with the Glob Operator"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:461
msgid ""
"If we want to bring _all_ public items defined in a path into scope, we can "
"specify that path followed by the `*` glob operator:"
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:468
msgid ""
"This `use` statement brings all public items defined in `std::collections` "
"into the current scope. Be careful when using the glob operator! Glob can "
"make it harder to tell what names are in scope and where a name used in your "
"program was defined. Additionally, if the dependency changes its "
"definitions, what you’ve imported changes as well, which may lead to "
"compiler errors when you upgrade the dependency if the dependency adds a "
"definition with the same name as a definition of yours in the same scope, "
"for example."
msgstr ""

#: src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md:476
msgid ""
"The glob operator is often used when testing to bring everything under test "
"into the `tests` module; we’ll talk about that in [“How to Write Tests”]"
"(ch11-01-writing-tests.html#how-to-write-tests)<!-- ignore --> in Chapter "
"11. The glob operator is also sometimes used as part of the prelude pattern: "
"See [the standard library documentation](../std/prelude/index.html#other-"
"preludes)<!-- ignore --> for more information on that pattern."
msgstr ""
