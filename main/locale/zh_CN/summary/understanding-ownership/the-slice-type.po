msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch04-03-slices.md:1
msgid "The Slice Type"
msgstr ""

#: src/ch04-03-slices.md:3
msgid ""
"_Slices_ let you reference a contiguous sequence of elements in a "
"[collection](ch08-00-common-collections.md)<!-- ignore -->. A slice is a "
"kind of reference, so it does not have ownership."
msgstr ""

#: src/ch04-03-slices.md:7
msgid ""
"Here’s a small programming problem: Write a function that takes a string of "
"words separated by spaces and returns the first word it finds in that "
"string. If the function doesn’t find a space in the string, the whole string "
"must be one word, so the entire string should be returned."
msgstr ""

#: src/ch04-03-slices.md:12
msgid ""
"Note: For the purposes of introducing slices, we are assuming ASCII only in "
"this section; a more thorough discussion of UTF-8 handling is in the "
"[“Storing UTF-8 Encoded Text with Strings”](ch08-02-strings.html#storing-"
"utf-8-encoded-text-with-strings)<!-- ignore --> section of Chapter 8."
msgstr ""

#: src/ch04-03-slices.md:17
msgid ""
"Let’s work through how we’d write the signature of this function without "
"using slices, to understand the problem that slices will solve:"
msgstr ""

#: src/ch04-03-slices.md:24
msgid ""
"The `first_word` function has a parameter of type `&String`. We don’t need "
"ownership, so this is fine. (In idiomatic Rust, functions do not take "
"ownership of their arguments unless they need to, and the reasons for that "
"will become clear as we keep going.) But what should we return? We don’t "
"really have a way to talk about _part_ of a string. However, we could return "
"the index of the end of the word, indicated by a space. Let’s try that, as "
"shown in Listing 4-7."
msgstr ""

#: src/ch04-03-slices.md:38 src/ch04-03-slices.md:60 src/ch04-03-slices.md:78
#: src/ch04-03-slices.md:112 src/ch04-03-slices.md:137
#: src/ch04-03-slices.md:264 src/ch04-03-slices.md:309
#: src/ch04-03-slices.md:397 src/ch04-03-slices.md:446
msgid "b' '"
msgstr ""

#: src/ch04-03-slices.md:51
msgid ""
"Because we need to go through the `String` element by element and check "
"whether a value is a space, we’ll convert our `String` to an array of bytes "
"using the `as_bytes` method."
msgstr ""

#: src/ch04-03-slices.md:71
msgid ""
"Next, we create an iterator over the array of bytes using the `iter` method:"
msgstr ""

#: src/ch04-03-slices.md:89
msgid ""
"We’ll discuss iterators in more detail in [Chapter 13](ch13-02-iterators."
"html)<!-- ignore -->. For now, know that `iter` is a method that returns "
"each element in a collection and that `enumerate` wraps the result of `iter` "
"and returns each element as part of a tuple instead. The first element of "
"the tuple returned from `enumerate` is the index, and the second element is "
"a reference to the element. This is a bit more convenient than calculating "
"the index ourselves."
msgstr ""

#: src/ch04-03-slices.md:96
msgid ""
"Because the `enumerate` method returns a tuple, we can use patterns to "
"destructure that tuple. We’ll be discussing patterns more in [Chapter 6]"
"(ch06-02-match.html#patterns-that-bind-to-values)<!-- ignore -->. In the "
"`for` loop, we specify a pattern that has `i` for the index in the tuple and "
"`&item` for the single byte in the tuple. Because we get a reference to the "
"element from `.iter().enumerate()`, we use `&` in the pattern."
msgstr ""

#: src/ch04-03-slices.md:103
msgid ""
"Inside the `for` loop, we search for the byte that represents the space by "
"using the byte literal syntax. If we find a space, we return the position. "
"Otherwise, we return the length of the string by using `s.len()`."
msgstr ""

#: src/ch04-03-slices.md:123
msgid ""
"We now have a way to find out the index of the end of the first word in the "
"string, but there’s a problem. We’re returning a `usize` on its own, but "
"it’s only a meaningful number in the context of the `&String`. In other "
"words, because it’s a separate value from the `String`, there’s no guarantee "
"that it will still be valid in the future. Consider the program in Listing "
"4-8 that uses the `first_word` function from Listing 4-7."
msgstr ""

#: src/ch04-03-slices.md:146 src/ch04-03-slices.md:187
#: src/ch04-03-slices.md:318 src/ch04-03-slices.md:406
#: src/ch04-03-slices.md:415 src/ch04-03-slices.md:455
#: src/ch04-03-slices.md:464
msgid "\"hello world\""
msgstr ""

#: src/ch04-03-slices.md:148
msgid "// word will get the value 5\n"
msgstr ""

#: src/ch04-03-slices.md:150
msgid "// this empties the String, making it equal to \"\"\n"
msgstr ""

#: src/ch04-03-slices.md:152
msgid ""
"// word still has the value 5 here, but s no longer has any content that we\n"
"    // could meaningfully use with the value 5, so word is now totally "
"invalid!\n"
msgstr ""

#: src/ch04-03-slices.md:159
msgid ""
"This program compiles without any errors and would also do so if we used "
"`word` after calling `s.clear()`. Because `word` isn’t connected to the "
"state of `s` at all, `word` still contains the value `5`. We could use that "
"value `5` with the variable `s` to try to extract the first word out, but "
"this would be a bug because the contents of `s` have changed since we saved "
"`5` in `word`."
msgstr ""

#: src/ch04-03-slices.md:165
msgid ""
"Having to worry about the index in `word` getting out of sync with the data "
"in `s` is tedious and error-prone! Managing these indices is even more "
"brittle if we write a `second_word` function. Its signature would have to "
"look like this:"
msgstr ""

#: src/ch04-03-slices.md:173
msgid ""
"Now we’re tracking a starting _and_ an ending index, and we have even more "
"values that were calculated from data in a particular state but aren’t tied "
"to that state at all. We have three unrelated variables floating around that "
"need to be kept in sync."
msgstr ""

#: src/ch04-03-slices.md:178
msgid "Luckily, Rust has a solution to this problem: string slices."
msgstr ""

#: src/ch04-03-slices.md:180
msgid "String Slices"
msgstr ""

#: src/ch04-03-slices.md:182
msgid ""
"A _string slice_ is a reference to a contiguous sequence of the elements of "
"a `String`, and it looks like this:"
msgstr ""

#: src/ch04-03-slices.md:194
msgid ""
"Rather than a reference to the entire `String`, `hello` is a reference to a "
"portion of the `String`, specified in the extra `[0..5]` bit. We create "
"slices using a range within square brackets by specifying `[starting_index.."
"ending_index]`, where _`starting_index`_ is the first position in the slice "
"and _`ending_index`_ is one more than the last position in the slice. "
"Internally, the slice data structure stores the starting position and the "
"length of the slice, which corresponds to _`ending_index`_ minus "
"_`starting_index`_. So, in the case of `let world = &s[6..11];`, `world` "
"would be a slice that contains a pointer to the byte at index 6 of `s` with "
"a length value of `5`."
msgstr ""

#: src/ch04-03-slices.md:205
msgid "Figure 4-7 shows this in a diagram."
msgstr ""

#: src/ch04-03-slices.md:207
msgid ""
"<img alt=\"Three tables: a table representing the stack data of s, which "
"points\n"
"to the byte at index 0 in a table of the string data &quot;hello world&quot; "
"on\n"
"the heap. The third table represents the stack data of the slice world, "
"which\n"
"has a length value of 5 and points to byte 6 of the heap data table.\"\n"
"src=\"img/trpl04-07.svg\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch04-03-slices.md:213
msgid ""
"<span class=\"caption\">Figure 4-7: A string slice referring to part of a "
"`String`</span>"
msgstr ""

#: src/ch04-03-slices.md:216
msgid ""
"With Rust’s `..` range syntax, if you want to start at index 0, you can drop "
"the value before the two periods. In other words, these are equal:"
msgstr ""

#: src/ch04-03-slices.md:220 src/ch04-03-slices.md:230
#: src/ch04-03-slices.md:242
msgid "\"hello\""
msgstr ""

#: src/ch04-03-slices.md:226
msgid ""
"By the same token, if your slice includes the last byte of the `String`, you "
"can drop the trailing number. That means these are equal:"
msgstr ""

#: src/ch04-03-slices.md:238
msgid ""
"You can also drop both values to take a slice of the entire string. So, "
"these are equal:"
msgstr ""

#: src/ch04-03-slices.md:250
msgid ""
"Note: String slice range indices must occur at valid UTF-8 character "
"boundaries. If you attempt to create a string slice in the middle of a "
"multibyte character, your program will exit with an error."
msgstr ""

#: src/ch04-03-slices.md:254
msgid ""
"With all this information in mind, let’s rewrite `first_word` to return a "
"slice. The type that signifies “string slice” is written as `&str`:"
msgstr ""

#: src/ch04-03-slices.md:277
msgid ""
"We get the index for the end of the word the same way we did in Listing 4-7, "
"by looking for the first occurrence of a space. When we find a space, we "
"return a string slice using the start of the string and the index of the "
"space as the starting and ending indices."
msgstr ""

#: src/ch04-03-slices.md:282
msgid ""
"Now when we call `first_word`, we get back a single value that is tied to "
"the underlying data. The value is made up of a reference to the starting "
"point of the slice and the number of elements in the slice."
msgstr ""

#: src/ch04-03-slices.md:286
msgid "Returning a slice would also work for a `second_word` function:"
msgstr ""

#: src/ch04-03-slices.md:292
msgid ""
"We now have a straightforward API that’s much harder to mess up because the "
"compiler will ensure that the references into the `String` remain valid. "
"Remember the bug in the program in Listing 4-8, when we got the index to the "
"end of the first word but then cleared the string so our index was invalid? "
"That code was logically incorrect but didn’t show any immediate errors. The "
"problems would show up later if we kept trying to use the first word index "
"with an emptied string. Slices make this bug impossible and let us know much "
"sooner that we have a problem with our code. Using the slice version of "
"`first_word` will throw a compile-time error:"
msgstr ""

#: src/ch04-03-slices.md:322
msgid "// error!\n"
msgstr ""

#: src/ch04-03-slices.md:324
msgid "\"the first word is: {word}\""
msgstr ""

#: src/ch04-03-slices.md:330
msgid "Here’s the compiler error:"
msgstr ""

#: src/ch04-03-slices.md:332
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling ownership v0.1.0 (file:///projects/ownership)\n"
"error[E0502]: cannot borrow `s` as mutable because it is also borrowed as "
"immutable\n"
"  --> src/main.rs:18:5\n"
"   |\n"
"16 |     let word = first_word(&s);\n"
"   |                           -- immutable borrow occurs here\n"
"17 |\n"
"18 |     s.clear(); // error!\n"
"   |     ^^^^^^^^^ mutable borrow occurs here\n"
"19 |\n"
"20 |     println!(\"the first word is: {word}\");\n"
"   |                                   ---- immutable borrow later used "
"here\n"
"\n"
"For more information about this error, try `rustc --explain E0502`.\n"
"error: could not compile `ownership` (bin \"ownership\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch04-03-slices.md:351
msgid ""
"Recall from the borrowing rules that if we have an immutable reference to "
"something, we cannot also take a mutable reference. Because `clear` needs to "
"truncate the `String`, it needs to get a mutable reference. The `println!` "
"after the call to `clear` uses the reference in `word`, so the immutable "
"reference must still be active at that point. Rust disallows the mutable "
"reference in `clear` and the immutable reference in `word` from existing at "
"the same time, and compilation fails. Not only has Rust made our API easier "
"to use, but it has also eliminated an entire class of errors at compile time!"
msgstr ""

#: src/ch04-03-slices.md:362
msgid "<a id=\"string-literals-are-slices\"></a>"
msgstr ""

#: src/ch04-03-slices.md:364
msgid "String Literals as Slices"
msgstr ""

#: src/ch04-03-slices.md:366
msgid ""
"Recall that we talked about string literals being stored inside the binary. "
"Now that we know about slices, we can properly understand string literals:"
msgstr ""

#: src/ch04-03-slices.md:370
msgid "\"Hello, world!\""
msgstr ""

#: src/ch04-03-slices.md:373
msgid ""
"The type of `s` here is `&str`: It’s a slice pointing to that specific point "
"of the binary. This is also why string literals are immutable; `&str` is an "
"immutable reference."
msgstr ""

#: src/ch04-03-slices.md:377
msgid "String Slices as Parameters"
msgstr ""

#: src/ch04-03-slices.md:379
msgid ""
"Knowing that you can take slices of literals and `String` values leads us to "
"one more improvement on `first_word`, and that’s its signature:"
msgstr ""

#: src/ch04-03-slices.md:386
msgid ""
"A more experienced Rustacean would write the signature shown in Listing 4-9 "
"instead because it allows us to use the same function on both `&String` "
"values and `&str` values."
msgstr ""

#: src/ch04-03-slices.md:408 src/ch04-03-slices.md:457
msgid ""
"// `first_word` works on slices of `String`s, whether partial or whole.\n"
msgstr ""

#: src/ch04-03-slices.md:411
msgid ""
"// `first_word` also works on references to `String`s, which are equivalent\n"
msgstr ""

#: src/ch04-03-slices.md:412
msgid "// to whole slices of `String`s.\n"
msgstr ""

#: src/ch04-03-slices.md:417
msgid ""
"// `first_word` works on slices of string literals, whether partial or\n"
msgstr ""

#: src/ch04-03-slices.md:418
msgid "// whole.\n"
msgstr ""

#: src/ch04-03-slices.md:422
msgid "// Because string literals *are* string slices already,\n"
msgstr ""

#: src/ch04-03-slices.md:423
msgid "// this works too, without the slice syntax!\n"
msgstr ""

#: src/ch04-03-slices.md:430
msgid ""
"If we have a string slice, we can pass that directly. If we have a `String`, "
"we can pass a slice of the `String` or a reference to the `String`. This "
"flexibility takes advantage of deref coercions, a feature we will cover in "
"the [“Using Deref Coercions in Functions and Methods”](ch15-02-deref."
"html#using-deref-coercions-in-functions-and-methods)<!--\n"
"ignore --> section of Chapter 15."
msgstr ""

#: src/ch04-03-slices.md:436
msgid ""
"Defining a function to take a string slice instead of a reference to a "
"`String` makes our API more general and useful without losing any "
"functionality:"
msgstr ""

#: src/ch04-03-slices.md:460
msgid ""
"// `first_word` also works on references to `String`s, which are equivalent\n"
"    // to whole slices of `String`s.\n"
msgstr ""

#: src/ch04-03-slices.md:466
msgid ""
"// `first_word` works on slices of string literals, whether partial or\n"
"    // whole.\n"
msgstr ""

#: src/ch04-03-slices.md:471
msgid ""
"// Because string literals *are* string slices already,\n"
"    // this works too, without the slice syntax!\n"
msgstr ""

#: src/ch04-03-slices.md:479
msgid "Other Slices"
msgstr ""

#: src/ch04-03-slices.md:481
msgid ""
"String slices, as you might imagine, are specific to strings. But there’s a "
"more general slice type too. Consider this array:"
msgstr ""

#: src/ch04-03-slices.md:488
msgid ""
"Just as we might want to refer to part of a string, we might want to refer "
"to part of an array. We’d do so like this:"
msgstr ""

#: src/ch04-03-slices.md:499
msgid ""
"This slice has the type `&[i32]`. It works the same way as string slices do, "
"by storing a reference to the first element and a length. You’ll use this "
"kind of slice for all sorts of other collections. We’ll discuss these "
"collections in detail when we talk about vectors in Chapter 8."
msgstr ""

#: src/ch04-03-slices.md:504
msgid "Summary"
msgstr ""

#: src/ch04-03-slices.md:506
msgid ""
"The concepts of ownership, borrowing, and slices ensure memory safety in "
"Rust programs at compile time. The Rust language gives you control over your "
"memory usage in the same way as other systems programming languages. But "
"having the owner of data automatically clean up that data when the owner "
"goes out of scope means you don’t have to write and debug extra code to get "
"this control."
msgstr ""

#: src/ch04-03-slices.md:512
msgid ""
"Ownership affects how lots of other parts of Rust work, so we’ll talk about "
"these concepts further throughout the rest of the book. Let’s move on to "
"Chapter 5 and look at grouping pieces of data together in a `struct`."
msgstr ""
