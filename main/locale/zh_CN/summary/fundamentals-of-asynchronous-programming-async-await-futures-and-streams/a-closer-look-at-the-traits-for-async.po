msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch17-05-traits-for-async.md:3
msgid "<a id=\"digging-into-the-traits-for-async\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:5
msgid "A Closer Look at the Traits for Async"
msgstr ""

#: src/ch17-05-traits-for-async.md:7
msgid ""
"Throughout the chapter, we’ve used the `Future`, `Stream`, and `StreamExt` "
"traits in various ways. So far, though, we’ve avoided getting too far into "
"the details of how they work or how they fit together, which is fine most of "
"the time for your day-to-day Rust work. Sometimes, though, you’ll encounter "
"situations where you’ll need to understand a few more of these traits’ "
"details, along with the `Pin` type and the `Unpin` trait. In this section, "
"we’ll dig in just enough to help in those scenarios, still leaving the "
"_really_ deep dive for other documentation."
msgstr ""

#: src/ch17-05-traits-for-async.md:18
msgid "<a id=\"future\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:20
msgid "The `Future` Trait"
msgstr ""

#: src/ch17-05-traits-for-async.md:22
msgid ""
"Let’s start by taking a closer look at how the `Future` trait works. Here’s "
"how Rust defines it:"
msgstr ""

#: src/ch17-05-traits-for-async.md:36
msgid ""
"That trait definition includes a bunch of new types and also some syntax we "
"haven’t seen before, so let’s walk through the definition piece by piece."
msgstr ""

#: src/ch17-05-traits-for-async.md:39
msgid ""
"First, `Future`’s associated type `Output` says what the future resolves to. "
"This is analogous to the `Item` associated type for the `Iterator` trait. "
"Second, `Future` has the `poll` method, which takes a special `Pin` "
"reference for its `self` parameter and a mutable reference to a `Context` "
"type, and returns a `Poll<Self::Output>`. We’ll talk more about `Pin` and "
"`Context` in a moment. For now, let’s focus on what the method returns, the "
"`Poll` type:"
msgstr ""

#: src/ch17-05-traits-for-async.md:53
msgid ""
"This `Poll` type is similar to an `Option`. It has one variant that has a "
"value, `Ready(T)`, and one that does not, `Pending`. `Poll` means something "
"quite different from `Option`, though! The `Pending` variant indicates that "
"the future still has work to do, so the caller will need to check again "
"later. The `Ready` variant indicates that the `Future` has finished its work "
"and the `T` value is available."
msgstr ""

#: src/ch17-05-traits-for-async.md:60
msgid ""
"Note: It’s rare to need to call `poll` directly, but if you do need to, keep "
"in mind that with most futures, the caller should not call `poll` again "
"after the future has returned `Ready`. Many futures will panic if polled "
"again after becoming ready. Futures that are safe to poll again will say so "
"explicitly in their documentation. This is similar to how `Iterator::next` "
"behaves."
msgstr ""

#: src/ch17-05-traits-for-async.md:66
msgid ""
"When you see code that uses `await`, Rust compiles it under the hood to code "
"that calls `poll`. If you look back at Listing 17-4, where we printed out "
"the page title for a single URL once it resolved, Rust compiles it into "
"something kind of (although not exactly) like this:"
msgstr ""

#: src/ch17-05-traits-for-async.md:74 src/ch17-05-traits-for-async.md:92
msgid "\"The title for {url} was {title}\""
msgstr ""

#: src/ch17-05-traits-for-async.md:75 src/ch17-05-traits-for-async.md:93
msgid "\"{url} had no title\""
msgstr ""

#: src/ch17-05-traits-for-async.md:78
msgid "// But what goes here?\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:83
msgid ""
"What should we do when the future is still `Pending`? We need some way to "
"try again, and again, and again, until the future is finally ready. In other "
"words, we need a loop:"
msgstr ""

#: src/ch17-05-traits-for-async.md:96
msgid "// continue\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:102
msgid ""
"If Rust compiled it to exactly that code, though, every `await` would be "
"blocking—exactly the opposite of what we were going for! Instead, Rust "
"ensures that the loop can hand off control to something that can pause work "
"on this future to work on other futures and then check this one again later. "
"As we’ve seen, that something is an async runtime, and this scheduling and "
"coordination work is one of its main jobs."
msgstr ""

#: src/ch17-05-traits-for-async.md:109
msgid ""
"In the [“Sending Data Between Two Tasks Using Message Passing”](ch17-02-"
"concurrency-with-async.md#sending-data-between-two-tasks-using-message-"
"passing)<!-- ignore --> section, we described waiting on `rx.recv`. The "
"`recv` call returns a future, and awaiting the future polls it. We noted "
"that a runtime will pause the future until it’s ready with either "
"`Some(message)` or `None` when the channel closes. With our deeper "
"understanding of the `Future` trait, and specifically `Future::poll`, we can "
"see how that works. The runtime knows the future isn’t ready when it returns "
"`Poll::Pending`. Conversely, the runtime knows the future _is_ ready and "
"advances it when `poll` returns `Poll::Ready(Some(message))` or `Poll::"
"Ready(None)`."
msgstr ""

#: src/ch17-05-traits-for-async.md:120
msgid ""
"The exact details of how a runtime does that are beyond the scope of this "
"book, but the key is to see the basic mechanics of futures: a runtime "
"_polls_ each future it is responsible for, putting the future back to sleep "
"when it is not yet ready."
msgstr ""

#: src/ch17-05-traits-for-async.md:127
msgid ""
"<a id=\"pinning-and-the-pin-and-unpin-traits\"></a> <a id=\"the-pin-and-"
"unpin-traits\"></a>"
msgstr ""

#: src/ch17-05-traits-for-async.md:130
msgid "The `Pin` Type and the `Unpin` Trait"
msgstr ""

#: src/ch17-05-traits-for-async.md:132
msgid ""
"Back in Listing 17-13, we used the `trpl::join!` macro to await three "
"futures. However, it’s common to have a collection such as a vector "
"containing some number futures that won’t be known until runtime. Let’s "
"change Listing 17-13 to the code in Listing 17-23 that puts the three "
"futures into a vector and calls the `trpl::join_all` function instead, which "
"won’t compile yet."
msgstr ""

#: src/ch17-05-traits-for-async.md:141 src/ch17-05-traits-for-async.md:462
msgid "// required for mdbook test\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:152 src/ch17-05-traits-for-async.md:478
msgid "\"hi\""
msgstr ""

#: src/ch17-05-traits-for-async.md:153 src/ch17-05-traits-for-async.md:479
msgid "\"from\""
msgstr ""

#: src/ch17-05-traits-for-async.md:154 src/ch17-05-traits-for-async.md:480
msgid "\"the\""
msgstr ""

#: src/ch17-05-traits-for-async.md:155 src/ch17-05-traits-for-async.md:481
msgid "\"future\""
msgstr ""

#: src/ch17-05-traits-for-async.md:166 src/ch17-05-traits-for-async.md:493
msgid "\"received '{value}'\""
msgstr ""

#: src/ch17-05-traits-for-async.md:171 src/ch17-05-traits-for-async.md:465
#: src/ch17-05-traits-for-async.md:476 src/ch17-05-traits-for-async.md:491
#: src/ch17-05-traits-for-async.md:498
msgid "// --snip--\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:173 src/ch17-05-traits-for-async.md:500
msgid "\"more\""
msgstr ""

#: src/ch17-05-traits-for-async.md:174 src/ch17-05-traits-for-async.md:501
msgid "\"messages\""
msgstr ""

#: src/ch17-05-traits-for-async.md:175 src/ch17-05-traits-for-async.md:502
msgid "\"for\""
msgstr ""

#: src/ch17-05-traits-for-async.md:176 src/ch17-05-traits-for-async.md:503
msgid "\"you\""
msgstr ""

#: src/ch17-05-traits-for-async.md:195
msgid ""
"We put each future within a `Box` to make them into _trait objects_, just as "
"we did in the “Returning Errors from `run`” section in Chapter 12. (We’ll "
"cover trait objects in detail in Chapter 18.) Using trait objects lets us "
"treat each of the anonymous futures produced by these types as the same "
"type, because all of them implement the `Future` trait."
msgstr ""

#: src/ch17-05-traits-for-async.md:201
msgid ""
"This might be surprising. After all, none of the async blocks returns "
"anything, so each one produces a `Future<Output = ()>`. Remember that "
"`Future` is a trait, though, and that the compiler creates a unique enum for "
"each async block, even when they have identical output types. Just as you "
"can’t put two different handwritten structs in a `Vec`, you can’t mix "
"compiler-generated enums."
msgstr ""

#: src/ch17-05-traits-for-async.md:208
msgid ""
"Then we pass the collection of futures to the `trpl::join_all` function and "
"await the result. However, this doesn’t compile; here’s the relevant part of "
"the error messages."
msgstr ""

#: src/ch17-05-traits-for-async.md:218
msgid ""
"```text\n"
"error[E0277]: `dyn Future<Output = ()>` cannot be unpinned\n"
"  --> src/main.rs:48:33\n"
"   |\n"
"48 |         trpl::join_all(futures).await;\n"
"   |                                 ^^^^^ the trait `Unpin` is not "
"implemented for `dyn Future<Output = ()>`\n"
"   |\n"
"   = note: consider using the `pin!` macro\n"
"           consider using `Box::pin` if you need to access the pinned value "
"outside of the current scope\n"
"   = note: required for `Box<dyn Future<Output = ()>>` to implement "
"`Future`\n"
"note: required by a bound in `futures_util::future::join_all::JoinAll`\n"
"  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/"
"futures-util-0.3.30/src/future/join_all.rs:29:8\n"
"   |\n"
"27 | pub struct JoinAll<F>\n"
"   |            ------- required by a bound in this struct\n"
"28 | where\n"
"29 |     F: Future,\n"
"   |        ^^^^^^ required by this bound in `JoinAll`\n"
"```"
msgstr ""

#: src/ch17-05-traits-for-async.md:238
msgid ""
"The note in this error message tells us that we should use the `pin!` macro "
"to _pin_ the values, which means putting them inside the `Pin` type that "
"guarantees the values won’t be moved in memory. The error message says "
"pinning is required because `dyn Future<Output = ()>` needs to implement the "
"`Unpin` trait and it currently does not."
msgstr ""

#: src/ch17-05-traits-for-async.md:244
msgid ""
"The `trpl::join_all` function returns a struct called `JoinAll`. That struct "
"is generic over a type `F`, which is constrained to implement the `Future` "
"trait. Directly awaiting a future with `await` pins the future implicitly. "
"That’s why we don’t need to use `pin!` everywhere we want to await futures."
msgstr ""

#: src/ch17-05-traits-for-async.md:249
msgid ""
"However, we’re not directly awaiting a future here. Instead, we construct a "
"new future, JoinAll, by passing a collection of futures to the `join_all` "
"function. The signature for `join_all` requires that the types of the items "
"in the collection all implement the `Future` trait, and `Box<T>` implements "
"`Future` only if the `T` it wraps is a future that implements the `Unpin` "
"trait."
msgstr ""

#: src/ch17-05-traits-for-async.md:255
msgid ""
"That’s a lot to absorb! To really understand it, let’s dive a little further "
"into how the `Future` trait actually works, in particular around pinning. "
"Look again at the definition of the `Future` trait:"
msgstr ""

#: src/ch17-05-traits-for-async.md:266
msgid "// Required method\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:271
msgid ""
"The `cx` parameter and its `Context` type are the key to how a runtime "
"actually knows when to check any given future while still being lazy. Again, "
"the details of how that works are beyond the scope of this chapter, and you "
"generally only need to think about this when writing a custom `Future` "
"implementation. We’ll focus instead on the type for `self`, as this is the "
"first time we’ve seen a method where `self` has a type annotation. A type "
"annotation for `self` works like type annotations for other function "
"parameters but with two key differences:"
msgstr ""

#: src/ch17-05-traits-for-async.md:280
msgid "It tells Rust what type `self` must be for the method to be called."
msgstr ""

#: src/ch17-05-traits-for-async.md:281
msgid ""
"It can’t be just any type. It’s restricted to the type on which the method "
"is implemented, a reference or smart pointer to that type, or a `Pin` "
"wrapping a reference to that type."
msgstr ""

#: src/ch17-05-traits-for-async.md:285
msgid ""
"We’ll see more on this syntax in [Chapter 18](ch18-00-oop.html)<!-- ignore --"
">. For now, it’s enough to know that if we want to poll a future to check "
"whether it is `Pending` or `Ready(Output)`, we need a `Pin`\\-wrapped "
"mutable reference to the type."
msgstr ""

#: src/ch17-05-traits-for-async.md:290
msgid ""
"`Pin` is a wrapper for pointer-like types such as `&`, `&mut`, `Box`, and "
"`Rc`. (Technically, `Pin` works with types that implement the `Deref` or "
"`DerefMut` traits, but this is effectively equivalent to working only with "
"references and smart pointers.) `Pin` is not a pointer itself and doesn’t "
"have any behavior of its own like `Rc` and `Arc` do with reference counting; "
"it’s purely a tool the compiler can use to enforce constraints on pointer "
"usage."
msgstr ""

#: src/ch17-05-traits-for-async.md:297
msgid ""
"Recalling that `await` is implemented in terms of calls to `poll` starts to "
"explain the error message we saw earlier, but that was in terms of `Unpin`, "
"not `Pin`. So how exactly does `Pin` relate to `Unpin`, and why does "
"`Future` need `self` to be in a `Pin` type to call `poll`?"
msgstr ""

#: src/ch17-05-traits-for-async.md:302
msgid ""
"Remember from earlier in this chapter that a series of await points in a "
"future get compiled into a state machine, and the compiler makes sure that "
"state machine follows all of Rust’s normal rules around safety, including "
"borrowing and ownership. To make that work, Rust looks at what data is "
"needed between one await point and either the next await point or the end of "
"the async block. It then creates a corresponding variant in the compiled "
"state machine. Each variant gets the access it needs to the data that will "
"be used in that section of the source code, whether by taking ownership of "
"that data or by getting a mutable or immutable reference to it."
msgstr ""

#: src/ch17-05-traits-for-async.md:312
msgid ""
"So far, so good: if we get anything wrong about the ownership or references "
"in a given async block, the borrow checker will tell us. When we want to "
"move around the future that corresponds to that block—like moving it into a "
"`Vec` to pass to `join_all`—things get trickier."
msgstr ""

#: src/ch17-05-traits-for-async.md:317
msgid ""
"When we move a future—whether by pushing it into a data structure to use as "
"an iterator with `join_all` or by returning it from a function—that actually "
"means moving the state machine Rust creates for us. And unlike most other "
"types in Rust, the futures Rust creates for async blocks can end up with "
"references to themselves in the fields of any given variant, as shown in the "
"simplified illustration in Figure 17-4."
msgstr ""

#: src/ch17-05-traits-for-async.md:331
msgid ""
"By default, though, any object that has a reference to itself is unsafe to "
"move, because references always point to the actual memory address of "
"whatever they refer to (see Figure 17-5). If you move the data structure "
"itself, those internal references will be left pointing to the old location. "
"However, that memory location is now invalid. For one thing, its value will "
"not be updated when you make changes to the data structure. For another—more "
"important—thing, the computer is now free to reuse that memory for other "
"purposes! You could end up reading completely unrelated data later."
msgstr ""

#: src/ch17-05-traits-for-async.md:348
msgid ""
"Theoretically, the Rust compiler could try to update every reference to an "
"object whenever it gets moved, but that could add a lot of performance "
"overhead, especially if a whole web of references needs updating. If we "
"could instead make sure the data structure in question _doesn’t move in "
"memory_, we wouldn’t have to update any references. This is exactly what "
"Rust’s borrow checker is for: in safe code, it prevents you from moving any "
"item with an active reference to it."
msgstr ""

#: src/ch17-05-traits-for-async.md:356
msgid ""
"`Pin` builds on that to give us the exact guarantee we need. When we _pin_ a "
"value by wrapping a pointer to that value in `Pin`, it can no longer move. "
"Thus, if you have `Pin<Box<SomeType>>`, you actually pin the `SomeType` "
"value, _not_ the `Box` pointer. Figure 17-6 illustrates this process."
msgstr ""

#: src/ch17-05-traits-for-async.md:369
msgid ""
"In fact, the `Box` pointer can still move around freely. Remember: we care "
"about making sure the data ultimately being referenced stays in place. If a "
"pointer moves around, _but the data it points to_ is in the same place, as "
"in Figure 17-7, there’s no potential problem. (As an independent exercise, "
"look at the docs for the types as well as the `std::pin` module and try to "
"work out how you’d do this with a `Pin` wrapping a `Box`.) The key is that "
"the self-referential type itself cannot move, because it is still pinned."
msgstr ""

#: src/ch17-05-traits-for-async.md:385
msgid ""
"However, most types are perfectly safe to move around, even if they happen "
"to be behind a `Pin` pointer. We only need to think about pinning when items "
"have internal references. Primitive values such as numbers and Booleans are "
"safe because they obviously don’t have any internal references. Neither do "
"most types you normally work with in Rust. You can move around a `Vec`, for "
"example, without worrying. Given what we have seen so far, if you have a "
"`Pin<Vec<String>>`, you’d have to do everything via the safe but restrictive "
"APIs provided by `Pin`, even though a `Vec<String>` is always safe to move "
"if there are no other references to it. We need a way to tell the compiler "
"that it’s fine to move items around in cases like this—and that’s where "
"`Unpin` comes into play."
msgstr ""

#: src/ch17-05-traits-for-async.md:397
msgid ""
"`Unpin` is a marker trait, similar to the `Send` and `Sync` traits we saw in "
"Chapter 16, and thus has no functionality of its own. Marker traits exist "
"only to tell the compiler it’s safe to use the type implementing a given "
"trait in a particular context. `Unpin` informs the compiler that a given "
"type does _not_ need to uphold any guarantees about whether the value in "
"question can be safely moved."
msgstr ""

#: src/ch17-05-traits-for-async.md:410
msgid ""
"Just as with `Send` and `Sync`, the compiler implements `Unpin` "
"automatically for all types where it can prove it is safe. A special case, "
"again similar to `Send` and `Sync`, is where `Unpin` is _not_ implemented "
"for a type. The notation for this is <code>impl !Unpin for <em>SomeType</"
"em></code>, where <code><em>SomeType</em></code> is the name of a type that "
"_does_ need to uphold those guarantees to be safe whenever a pointer to that "
"type is used in a `Pin`."
msgstr ""

#: src/ch17-05-traits-for-async.md:417
msgid ""
"In other words, there are two things to keep in mind about the relationship "
"between `Pin` and `Unpin`. First, `Unpin` is the “normal” case, and `!Unpin` "
"is the special case. Second, whether a type implements `Unpin` or `!Unpin` "
"_only_ matters when you’re using a pinned pointer to that type like "
"<code>Pin\\<&mut <em>SomeType</em>\\></code>."
msgstr ""

#: src/ch17-05-traits-for-async.md:423
msgid ""
"To make that concrete, think about a `String`: it has a length and the "
"Unicode characters that make it up. We can wrap a `String` in `Pin`, as seen "
"in Figure 17-8. However, `String` automatically implements `Unpin`, as do "
"most other types in Rust."
msgstr ""

#: src/ch17-05-traits-for-async.md:436
msgid ""
"As a result, we can do things that would be illegal if `String` implemented "
"`!Unpin` instead, such as replacing one string with another at the exact "
"same location in memory as in Figure 17-9. This doesn’t violate the `Pin` "
"contract, because `String` has no internal references that make it unsafe to "
"move around. That is precisely why it implements `Unpin` rather than `!"
"Unpin`."
msgstr ""

#: src/ch17-05-traits-for-async.md:450
msgid ""
"Now we know enough to understand the errors reported for that `join_all` "
"call from back in Listing 17-23. We originally tried to move the futures "
"produced by async blocks into a `Vec<Box<dyn Future<Output = ()>>>`, but as "
"we’ve seen, those futures may have internal references, so they don’t "
"automatically implement `Unpin`. Once we pin them, we can pass the resulting "
"`Pin` type into the `Vec`, confident that the underlying data in the futures "
"will _not_ be moved. Listing 17-24 shows how to fix the code by calling the "
"`pin!` macro where each of the three futures are defined and adjusting the "
"trait object type."
msgstr ""

#: src/ch17-05-traits-for-async.md:522
msgid ""
"This example now compiles and runs, and we could add or remove futures from "
"the vector at runtime and join them all."
msgstr ""

#: src/ch17-05-traits-for-async.md:525
msgid ""
"`Pin` and `Unpin` are mostly important for building lower-level libraries, "
"or when you’re building a runtime itself, rather than for day-to-day Rust "
"code. When you see these traits in error messages, though, now you’ll have a "
"better idea of how to fix your code!"
msgstr ""

#: src/ch17-05-traits-for-async.md:530
msgid ""
"Note: This combination of `Pin` and `Unpin` makes it possible to safely "
"implement a whole class of complex types in Rust that would otherwise prove "
"challenging because they’re self-referential. Types that require `Pin` show "
"up most commonly in async Rust today, but every once in a while, you might "
"see them in other contexts, too."
msgstr ""

#: src/ch17-05-traits-for-async.md:536
msgid ""
"The specifics of how `Pin` and `Unpin` work, and the rules they’re required "
"to uphold, are covered extensively in the API documentation for `std::pin`, "
"so if you’re interested in learning more, that’s a great place to start."
msgstr ""

#: src/ch17-05-traits-for-async.md:540
msgid ""
"If you want to understand how things work under the hood in even more "
"detail, see Chapters [2](https://rust-lang.github.io/async-"
"book/02_execution/01_chapter.html)<!-- ignore --> and [4](https://rust-lang."
"github.io/async-book/04_pinning/01_chapter.html)<!-- ignore --> of "
"[_Asynchronous Programming in Rust_](https://rust-lang.github.io/async-"
"book/)."
msgstr ""

#: src/ch17-05-traits-for-async.md:545
msgid "The `Stream` Trait"
msgstr ""

#: src/ch17-05-traits-for-async.md:547
msgid ""
"Now that you have a deeper grasp on the `Future`, `Pin`, and `Unpin` traits, "
"we can turn our attention to the `Stream` trait. As you learned earlier in "
"the chapter, streams are similar to asynchronous iterators. Unlike "
"`Iterator` and `Future`, however, `Stream` has no definition in the standard "
"library as of this writing, but there _is_ a very common definition from the "
"`futures` crate used throughout the ecosystem."
msgstr ""

#: src/ch17-05-traits-for-async.md:554
msgid ""
"Let’s review the definitions of the `Iterator` and `Future` traits before "
"looking at how a `Stream` trait might merge them together. From `Iterator`, "
"we have the idea of a sequence: its `next` method provides an `Option<Self::"
"Item>`. From `Future`, we have the idea of readiness over time: its `poll` "
"method provides a `Poll<Self::Output>`. To represent a sequence of items "
"that become ready over time, we define a `Stream` trait that puts those "
"features together:"
msgstr ""

#: src/ch17-05-traits-for-async.md:576
msgid ""
"The `Stream` trait defines an associated type called `Item` for the type of "
"the items produced by the stream. This is similar to `Iterator`, where there "
"may be zero to many items, and unlike `Future`, where there is always a "
"single `Output`, even if it’s the unit type `()`."
msgstr ""

#: src/ch17-05-traits-for-async.md:581
msgid ""
"`Stream` also defines a method to get those items. We call it `poll_next`, "
"to make it clear that it polls in the same way `Future::poll` does and "
"produces a sequence of items in the same way `Iterator::next` does. Its "
"return type combines `Poll` with `Option`. The outer type is `Poll`, because "
"it has to be checked for readiness, just as a future does. The inner type is "
"`Option`, because it needs to signal whether there are more messages, just "
"as an iterator does."
msgstr ""

#: src/ch17-05-traits-for-async.md:589
msgid ""
"Something very similar to this definition will likely end up as part of "
"Rust’s standard library. In the meantime, it’s part of the toolkit of most "
"runtimes, so you can rely on it, and everything we cover next should "
"generally apply!"
msgstr ""

#: src/ch17-05-traits-for-async.md:593
msgid ""
"In the examples we saw in the [“Streams: Futures in Sequence”](ch17-04-"
"streams.html)<!--\n"
"ignore --> section, though, we didn’t use `poll_next` _or_ `Stream`, but "
"instead used `next` and `StreamExt`. We _could_ work directly in terms of "
"the `poll_next` API by hand-writing our own `Stream` state machines, of "
"course, just as we _could_ work with futures directly via their `poll` "
"method. Using `await` is much nicer, though, and the `StreamExt` trait "
"supplies the `next` method so we can do just that:"
msgstr ""

#: src/ch17-05-traits-for-async.md:618
msgid "// other methods...\n"
msgstr ""

#: src/ch17-05-traits-for-async.md:627
msgid ""
"Note: The actual definition we used earlier in the chapter looks slightly "
"different than this, because it supports versions of Rust that did not yet "
"support using async functions in traits. As a result, it looks like this:"
msgstr ""

#: src/ch17-05-traits-for-async.md:635
msgid ""
"That `Next` type is a `struct` that implements `Future` and allows us to "
"name the lifetime of the reference to `self` with `Next<'_, Self>`, so that "
"`await` can work with this method."
msgstr ""

#: src/ch17-05-traits-for-async.md:639
msgid ""
"The `StreamExt` trait is also the home of all the interesting methods "
"available to use with streams. `StreamExt` is automatically implemented for "
"every type that implements `Stream`, but these traits are defined separately "
"to enable the community to iterate on convenience APIs without affecting the "
"foundational trait."
msgstr ""

#: src/ch17-05-traits-for-async.md:645
msgid ""
"In the version of `StreamExt` used in the `trpl` crate, the trait not only "
"defines the `next` method but also supplies a default implementation of "
"`next` that correctly handles the details of calling `Stream::poll_next`. "
"This means that even when you need to write your own streaming data type, "
"you _only_ have to implement `Stream`, and then anyone who uses your data "
"type can use `StreamExt` and its methods with it automatically."
msgstr ""

#: src/ch17-05-traits-for-async.md:652
msgid ""
"That’s all we’re going to cover for the lower-level details on these traits. "
"To wrap up, let’s consider how futures (including streams), tasks, and "
"threads all fit together!"
msgstr ""
