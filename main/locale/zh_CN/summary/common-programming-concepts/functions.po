msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch03-03-how-functions-work.md:1
msgid "Functions"
msgstr ""

#: src/ch03-03-how-functions-work.md:3
msgid ""
"Functions are prevalent in Rust code. You’ve already seen one of the most "
"important functions in the language: the `main` function, which is the entry "
"point of many programs. You’ve also seen the `fn` keyword, which allows you "
"to declare new functions."
msgstr ""

#: src/ch03-03-how-functions-work.md:8
msgid ""
"Rust code uses _snake case_ as the conventional style for function and "
"variable names, in which all letters are lowercase and underscores separate "
"words. Here’s a program that contains an example function definition:"
msgstr ""

#: src/ch03-03-how-functions-work.md:12 src/ch03-03-how-functions-work.md:66
#: src/ch03-03-how-functions-work.md:102 src/ch03-03-how-functions-work.md:171
#: src/ch03-03-how-functions-work.md:223 src/ch03-03-how-functions-work.md:262
#: src/ch03-03-how-functions-work.md:305 src/ch03-03-how-functions-work.md:323
msgid "<span class=\"filename\">Filename: src/main.rs</span>"
msgstr ""

#: src/ch03-03-how-functions-work.md:16
msgid "\"Hello, world!\""
msgstr ""

#: src/ch03-03-how-functions-work.md:22
msgid "\"Another function.\""
msgstr ""

#: src/ch03-03-how-functions-work.md:26
msgid ""
"We define a function in Rust by entering `fn` followed by a function name "
"and a set of parentheses. The curly brackets tell the compiler where the "
"function body begins and ends."
msgstr ""

#: src/ch03-03-how-functions-work.md:30
msgid ""
"We can call any function we’ve defined by entering its name followed by a "
"set of parentheses. Because `another_function` is defined in the program, it "
"can be called from inside the `main` function. Note that we defined "
"`another_function` _after_ the `main` function in the source code; we could "
"have defined it before as well. Rust doesn’t care where you define your "
"functions, only that they’re defined somewhere in a scope that can be seen "
"by the caller."
msgstr ""

#: src/ch03-03-how-functions-work.md:37
msgid ""
"Let’s start a new binary project named _functions_ to explore functions "
"further. Place the `another_function` example in _src/main.rs_ and run it. "
"You should see the following output:"
msgstr ""

#: src/ch03-03-how-functions-work.md:41
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s\n"
"     Running `target/debug/functions`\n"
"Hello, world!\n"
"Another function.\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:50
msgid ""
"The lines execute in the order in which they appear in the `main` function. "
"First the “Hello, world!” message prints, and then `another_function` is "
"called and its message is printed."
msgstr ""

#: src/ch03-03-how-functions-work.md:54
msgid "Parameters"
msgstr ""

#: src/ch03-03-how-functions-work.md:56
msgid ""
"We can define functions to have _parameters_, which are special variables "
"that are part of a function’s signature. When a function has parameters, you "
"can provide it with concrete values for those parameters. Technically, the "
"concrete values are called _arguments_, but in casual conversation, people "
"tend to use the words _parameter_ and _argument_ interchangeably for either "
"the variables in a function’s definition or the concrete values passed in "
"when you call a function."
msgstr ""

#: src/ch03-03-how-functions-work.md:64
msgid "In this version of `another_function` we add a parameter:"
msgstr ""

#: src/ch03-03-how-functions-work.md:74 src/ch03-03-how-functions-work.md:272
#: src/ch03-03-how-functions-work.md:311 src/ch03-03-how-functions-work.md:329
msgid "\"The value of x is: {x}\""
msgstr ""

#: src/ch03-03-how-functions-work.md:78
msgid "Try running this program; you should get the following output:"
msgstr ""

#: src/ch03-03-how-functions-work.md:80
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:88
msgid ""
"The declaration of `another_function` has one parameter named `x`. The type "
"of `x` is specified as `i32`. When we pass `5` in to `another_function`, the "
"`println!` macro puts `5` where the pair of curly brackets containing `x` "
"was in the format string."
msgstr ""

#: src/ch03-03-how-functions-work.md:93
msgid ""
"In function signatures, you _must_ declare the type of each parameter. This "
"is a deliberate decision in Rust’s design: Requiring type annotations in "
"function definitions means the compiler almost never needs you to use them "
"elsewhere in the code to figure out what type you mean. The compiler is also "
"able to give more-helpful error messages if it knows what types the function "
"expects."
msgstr ""

#: src/ch03-03-how-functions-work.md:99
msgid ""
"When defining multiple parameters, separate the parameter declarations with "
"commas, like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:106
msgid "'h'"
msgstr ""

#: src/ch03-03-how-functions-work.md:110
msgid "\"The measurement is: {value}{unit_label}\""
msgstr ""

#: src/ch03-03-how-functions-work.md:114
msgid ""
"This example creates a function named `print_labeled_measurement` with two "
"parameters. The first parameter is named `value` and is an `i32`. The second "
"is named `unit_label` and is type `char`. The function then prints text "
"containing both the `value` and the `unit_label`."
msgstr ""

#: src/ch03-03-how-functions-work.md:119
msgid ""
"Let’s try running this code. Replace the program currently in your "
"_functions_ project’s _src/main.rs_ file with the preceding example and run "
"it using `cargo run`:"
msgstr ""

#: src/ch03-03-how-functions-work.md:123
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n"
"     Running `target/debug/functions`\n"
"The measurement is: 5h\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:131
msgid ""
"Because we called the function with `5` as the value for `value` and `'h'` "
"as the value for `unit_label`, the program output contains those values."
msgstr ""

#: src/ch03-03-how-functions-work.md:134
msgid "Statements and Expressions"
msgstr ""

#: src/ch03-03-how-functions-work.md:136
msgid ""
"Function bodies are made up of a series of statements optionally ending in "
"an expression. So far, the functions we’ve covered haven’t included an "
"ending expression, but you have seen an expression as part of a statement. "
"Because Rust is an expression-based language, this is an important "
"distinction to understand. Other languages don’t have the same distinctions, "
"so let’s look at what statements and expressions are and how their "
"differences affect the bodies of functions."
msgstr ""

#: src/ch03-03-how-functions-work.md:144
msgid ""
"_Statements_ are instructions that perform some action and do not return a "
"value."
msgstr ""

#: src/ch03-03-how-functions-work.md:146
msgid "_Expressions_ evaluate to a resultant value."
msgstr ""

#: src/ch03-03-how-functions-work.md:148
msgid "Let’s look at some examples."
msgstr ""

#: src/ch03-03-how-functions-work.md:150
msgid ""
"We’ve actually already used statements and expressions. Creating a variable "
"and assigning a value to it with the `let` keyword is a statement. In "
"Listing 3-1, `let y = 6;` is a statement."
msgstr ""

#: src/ch03-03-how-functions-work.md:164
msgid ""
"Function definitions are also statements; the entire preceding example is a "
"statement in itself. (As we’ll see shortly, calling a function is not a "
"statement, though.)"
msgstr ""

#: src/ch03-03-how-functions-work.md:168
msgid ""
"Statements do not return values. Therefore, you can’t assign a `let` "
"statement to another variable, as the following code tries to do; you’ll get "
"an error:"
msgstr ""

#: src/ch03-03-how-functions-work.md:179
msgid "When you run this program, the error you’ll get looks like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:181
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error: expected expression, found `let` statement\n"
" --> src/main.rs:2:14\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |              ^^^\n"
"  |\n"
"  = note: only supported directly in conditions of `if` and `while` "
"expressions\n"
"\n"
"warning: unnecessary parentheses around assigned value\n"
" --> src/main.rs:2:13\n"
"  |\n"
"2 |     let x = (let y = 6);\n"
"  |             ^         ^\n"
"  |\n"
"  = note: `#[warn(unused_parens)]` on by default\n"
"help: remove these parentheses\n"
"  |\n"
"2 -     let x = (let y = 6);\n"
"2 +     let x = let y = 6;\n"
"  |\n"
"\n"
"warning: `functions` (bin \"functions\") generated 1 warning\n"
"error: could not compile `functions` (bin \"functions\") due to 1 previous "
"error; 1 warning emitted\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:209
msgid ""
"The `let y = 6` statement does not return a value, so there isn’t anything "
"for `x` to bind to. This is different from what happens in other languages, "
"such as C and Ruby, where the assignment returns the value of the "
"assignment. In those languages, you can write `x = y = 6` and have both `x` "
"and `y` have the value `6`; that is not the case in Rust."
msgstr ""

#: src/ch03-03-how-functions-work.md:215
msgid ""
"Expressions evaluate to a value and make up most of the rest of the code "
"that you’ll write in Rust. Consider a math operation, such as `5 + 6`, which "
"is an expression that evaluates to the value `11`. Expressions can be part "
"of statements: In Listing 3-1, the `6` in the statement `let y = 6;` is an "
"expression that evaluates to the value `6`. Calling a function is an "
"expression. Calling a macro is an expression. A new scope block created with "
"curly brackets is an expression, for example:"
msgstr ""

#: src/ch03-03-how-functions-work.md:232
msgid "\"The value of y is: {y}\""
msgstr ""

#: src/ch03-03-how-functions-work.md:236
msgid "This expression:"
msgstr ""

#: src/ch03-03-how-functions-work.md:245
msgid ""
"is a block that, in this case, evaluates to `4`. That value gets bound to "
"`y` as part of the `let` statement. Note the `x + 1` line without a "
"semicolon at the end, which is unlike most of the lines you’ve seen so far. "
"Expressions do not include ending semicolons. If you add a semicolon to the "
"end of an expression, you turn it into a statement, and it will then not "
"return a value. Keep this in mind as you explore function return values and "
"expressions next."
msgstr ""

#: src/ch03-03-how-functions-work.md:252
msgid "Functions with Return Values"
msgstr ""

#: src/ch03-03-how-functions-work.md:254
msgid ""
"Functions can return values to the code that calls them. We don’t name "
"return values, but we must declare their type after an arrow (`->`). In "
"Rust, the return value of the function is synonymous with the value of the "
"final expression in the block of the body of a function. You can return "
"early from a function by using the `return` keyword and specifying a value, "
"but most functions return the last expression implicitly. Here’s an example "
"of a function that returns a value:"
msgstr ""

#: src/ch03-03-how-functions-work.md:276
msgid ""
"There are no function calls, macros, or even `let` statements in the `five` "
"function—just the number `5` by itself. That’s a perfectly valid function in "
"Rust. Note that the function’s return type is specified too, as `-> i32`. "
"Try running this code; the output should look like this:"
msgstr ""

#: src/ch03-03-how-functions-work.md:281
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n"
"     Running `target/debug/functions`\n"
"The value of x is: 5\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:289
msgid ""
"The `5` in `five` is the function’s return value, which is why the return "
"type is `i32`. Let’s examine this in more detail. There are two important "
"bits: First, the line `let x = five();` shows that we’re using the return "
"value of a function to initialize a variable. Because the function `five` "
"returns a `5`, that line is the same as the following:"
msgstr ""

#: src/ch03-03-how-functions-work.md:299
msgid ""
"Second, the `five` function has no parameters and defines the type of the "
"return value, but the body of the function is a lonely `5` with no semicolon "
"because it’s an expression whose value we want to return."
msgstr ""

#: src/ch03-03-how-functions-work.md:303
msgid "Let’s look at another example:"
msgstr ""

#: src/ch03-03-how-functions-work.md:319
msgid ""
"Running this code will print `The value of x is: 6`. But what happens if we "
"place a semicolon at the end of the line containing `x + 1`, changing it "
"from an expression to a statement?"
msgstr ""

#: src/ch03-03-how-functions-work.md:337
msgid "Compiling this code will produce an error, as follows:"
msgstr ""

#: src/ch03-03-how-functions-work.md:339
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling functions v0.1.0 (file:///projects/functions)\n"
"error[E0308]: mismatched types\n"
" --> src/main.rs:7:24\n"
"  |\n"
"7 | fn plus_one(x: i32) -> i32 {\n"
"  |    --------            ^^^ expected `i32`, found `()`\n"
"  |    |\n"
"  |    implicitly returns `()` as its body has no tail or `return` "
"expression\n"
"8 |     x + 1;\n"
"  |          - help: remove this semicolon to return this value\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `functions` (bin \"functions\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch03-03-how-functions-work.md:356
msgid ""
"The main error message, `mismatched types`, reveals the core issue with this "
"code. The definition of the function `plus_one` says that it will return an "
"`i32`, but statements don’t evaluate to a value, which is expressed by `()`, "
"the unit type. Therefore, nothing is returned, which contradicts the "
"function definition and results in an error. In this output, Rust provides a "
"message to possibly help rectify this issue: It suggests removing the "
"semicolon, which would fix the error."
msgstr ""
