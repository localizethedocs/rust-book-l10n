msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch15-04-rc.md:1
msgid "`Rc<T>`, the Reference-Counted Smart Pointer"
msgstr ""

#: src/ch15-04-rc.md:3
msgid ""
"In the majority of cases, ownership is clear: You know exactly which "
"variable owns a given value. However, there are cases when a single value "
"might have multiple owners. For example, in graph data structures, multiple "
"edges might point to the same node, and that node is conceptually owned by "
"all of the edges that point to it. A node shouldn’t be cleaned up unless it "
"doesn’t have any edges pointing to it and so has no owners."
msgstr ""

#: src/ch15-04-rc.md:10
msgid ""
"You have to enable multiple ownership explicitly by using the Rust type "
"`Rc<T>`, which is an abbreviation for _reference counting_. The `Rc<T>` type "
"keeps track of the number of references to a value to determine whether or "
"not the value is still in use. If there are zero references to a value, the "
"value can be cleaned up without any references becoming invalid."
msgstr ""

#: src/ch15-04-rc.md:16
msgid ""
"Imagine `Rc<T>` as a TV in a family room. When one person enters to watch "
"TV, they turn it on. Others can come into the room and watch the TV. When "
"the last person leaves the room, they turn off the TV because it’s no longer "
"being used. If someone turns off the TV while others are still watching it, "
"there would be an uproar from the remaining TV watchers!"
msgstr ""

#: src/ch15-04-rc.md:22
msgid ""
"We use the `Rc<T>` type when we want to allocate some data on the heap for "
"multiple parts of our program to read and we can’t determine at compile time "
"which part will finish using the data last. If we knew which part would "
"finish last, we could just make that part the data’s owner, and the normal "
"ownership rules enforced at compile time would take effect."
msgstr ""

#: src/ch15-04-rc.md:28
msgid ""
"Note that `Rc<T>` is only for use in single-threaded scenarios. When we "
"discuss concurrency in Chapter 16, we’ll cover how to do reference counting "
"in multithreaded programs."
msgstr ""

#: src/ch15-04-rc.md:34
msgid "<a id=\"using-rct-to-share-data\"></a>"
msgstr ""

#: src/ch15-04-rc.md:36
msgid "Sharing Data"
msgstr ""

#: src/ch15-04-rc.md:38
msgid ""
"Let’s return to our cons list example in Listing 15-5. Recall that we "
"defined it using `Box<T>`. This time, we’ll create two lists that both share "
"ownership of a third list. Conceptually, this looks similar to Figure 15-3."
msgstr ""

#: src/ch15-04-rc.md:42
msgid ""
"<img alt=\"A linked list with the label 'a' pointing to three elements. The "
"first element contains the integer 5 and points to the second element. Th\n"
"e second element contains the integer 10 and points to the third element. "
"The third element contains the value 'Nil' that signifies the end of the l\n"
"ist; it does not point anywhere. A linked list with the label 'b' points to "
"an element that contains the integer 3 and points to the first element o\n"
"f list 'a'. A linked list with the label 'c' points to an element that "
"contains the integer 4 and also points to the first element of list 'a' so "
"th\n"
"at the tails of lists 'b' and 'c' are both list 'a'.\" src=\"img/trpl15-03."
"svg\" class=\"center\" />"
msgstr ""

#: src/ch15-04-rc.md:48
msgid ""
"<span class=\"caption\">Figure 15-3: Two lists, `b` and `c`, sharing "
"ownership of a third list, `a`</span>"
msgstr ""

#: src/ch15-04-rc.md:51
msgid ""
"We’ll create list `a` that contains `5` and then `10`. Then, we’ll make two "
"more lists: `b` that starts with `3` and `c` that starts with `4`. Both the "
"`b` and `c` lists will then continue on to the first `a` list containing `5` "
"and `10`. In other words, both lists will share the first list containing "
"`5` and `10`."
msgstr ""

#: src/ch15-04-rc.md:57
msgid ""
"Trying to implement this scenario using our definition of `List` with "
"`Box<T>` won’t work, as shown in Listing 15-17."
msgstr ""

#: src/ch15-04-rc.md:79
msgid "When we compile this code, we get this error:"
msgstr ""

#: src/ch15-04-rc.md:81
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"error[E0382]: use of moved value: `a`\n"
"  --> src/main.rs:11:30\n"
"   |\n"
" 9 |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n"
"   |         - move occurs because `a` has type `List`, which does not "
"implement the `Copy` trait\n"
"10 |     let b = Cons(3, Box::new(a));\n"
"   |                              - value moved here\n"
"11 |     let c = Cons(4, Box::new(a));\n"
"   |                              ^ value used here after move\n"
"   |\n"
"note: if `List` implemented `Clone`, you could clone the value\n"
"  --> src/main.rs:1:1\n"
"   |\n"
" 1 | enum List {\n"
"   | ^^^^^^^^^ consider implementing `Clone` for this type\n"
"...\n"
"10 |     let b = Cons(3, Box::new(a));\n"
"   |                              - you could clone this value\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `cons-list` (bin \"cons-list\") due to 1 previous "
"error\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:107
msgid ""
"The `Cons` variants own the data they hold, so when we create the `b` list, "
"`a` is moved into `b` and `b` owns `a`. Then, when we try to use `a` again "
"when creating `c`, we’re not allowed to because `a` has been moved."
msgstr ""

#: src/ch15-04-rc.md:111
msgid ""
"We could change the definition of `Cons` to hold references instead, but "
"then we would have to specify lifetime parameters. By specifying lifetime "
"parameters, we would be specifying that every element in the list will live "
"at least as long as the entire list. This is the case for the elements and "
"lists in Listing 15-17, but not in every scenario."
msgstr ""

#: src/ch15-04-rc.md:117
msgid ""
"Instead, we’ll change our definition of `List` to use `Rc<T>` in place of "
"`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a "
"value and an `Rc<T>` pointing to a `List`. When we create `b`, instead of "
"taking ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, "
"thereby increasing the number of references from one to two and letting `a` "
"and `b` share ownership of the data in that `Rc<List>`. We’ll also clone `a` "
"when creating `c`, increasing the number of references from two to three. "
"Every time we call `Rc::clone`, the reference count to the data within the "
"`Rc<List>` will increase, and the data won’t be cleaned up unless there are "
"zero references to it."
msgstr ""

#: src/ch15-04-rc.md:148
msgid ""
"We need to add a `use` statement to bring `Rc<T>` into scope because it’s "
"not in the prelude. In `main`, we create the list holding `5` and `10` and "
"store it in a new `Rc<List>` in `a`. Then, when we create `b` and `c`, we "
"call the `Rc::clone` function and pass a reference to the `Rc<List>` in `a` "
"as an argument."
msgstr ""

#: src/ch15-04-rc.md:154
msgid ""
"We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s "
"convention is to use `Rc::clone` in this case. The implementation of `Rc::"
"clone` doesn’t make a deep copy of all the data like most types’ "
"implementations of `clone` do. The call to `Rc::clone` only increments the "
"reference count, which doesn’t take much time. Deep copies of data can take "
"a lot of time. By using `Rc::clone` for reference counting, we can visually "
"distinguish between the deep-copy kinds of clones and the kinds of clones "
"that increase the reference count. When looking for performance problems in "
"the code, we only need to consider the deep-copy clones and can disregard "
"calls to `Rc::clone`."
msgstr ""

#: src/ch15-04-rc.md:167
msgid "<a id=\"cloning-an-rct-increases-the-reference-count\"></a>"
msgstr ""

#: src/ch15-04-rc.md:169
msgid "Cloning to Increase the Reference Count"
msgstr ""

#: src/ch15-04-rc.md:171
msgid ""
"Let’s change our working example in Listing 15-18 so that we can see the "
"reference counts changing as we create and drop references to the `Rc<List>` "
"in `a`."
msgstr ""

#: src/ch15-04-rc.md:175
msgid ""
"In Listing 15-19, we’ll change `main` so that it has an inner scope around "
"list `c`; then, we can see how the reference count changes when `c` goes out "
"of scope."
msgstr ""

#: src/ch15-04-rc.md:189
msgid "// --snip--\n"
msgstr ""

#: src/ch15-04-rc.md:194
msgid "\"count after creating a = {}\""
msgstr ""

#: src/ch15-04-rc.md:196
msgid "\"count after creating b = {}\""
msgstr ""

#: src/ch15-04-rc.md:199
msgid "\"count after creating c = {}\""
msgstr ""

#: src/ch15-04-rc.md:201
msgid "\"count after c goes out of scope = {}\""
msgstr ""

#: src/ch15-04-rc.md:207
msgid ""
"At each point in the program where the reference count changes, we print the "
"reference count, which we get by calling the `Rc::strong_count` function. "
"This function is named `strong_count` rather than `count` because the "
"`Rc<T>` type also has a `weak_count`; we’ll see what `weak_count` is used "
"for in [“Preventing Reference Cycles Using `Weak<T>`”](ch15-06-reference-"
"cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt)<!-- "
"ignore -->."
msgstr ""

#: src/ch15-04-rc.md:213
msgid "This code prints the following:"
msgstr ""

#: src/ch15-04-rc.md:215
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n"
"     Running `target/debug/cons-list`\n"
"count after creating a = 1\n"
"count after creating b = 2\n"
"count after creating c = 3\n"
"count after c goes out of scope = 2\n"
"```"
msgstr ""

#: src/ch15-04-rc.md:226
msgid ""
"We can see that the `Rc<List>` in `a` has an initial reference count of 1; "
"then, each time we call `clone`, the count goes up by 1. When `c` goes out "
"of scope, the count goes down by 1. We don’t have to call a function to "
"decrease the reference count like we have to call `Rc::clone` to increase "
"the reference count: The implementation of the `Drop` trait decreases the "
"reference count automatically when an `Rc<T>` value goes out of scope."
msgstr ""

#: src/ch15-04-rc.md:233
msgid ""
"What we can’t see in this example is that when `b` and then `a` go out of "
"scope at the end of `main`, the count is 0, and the `Rc<List>` is cleaned up "
"completely. Using `Rc<T>` allows a single value to have multiple owners, and "
"the count ensures that the value remains valid as long as any of the owners "
"still exist."
msgstr ""

#: src/ch15-04-rc.md:239
msgid ""
"Via immutable references, `Rc<T>` allows you to share data between multiple "
"parts of your program for reading only. If `Rc<T>` allowed you to have "
"multiple mutable references too, you might violate one of the borrowing "
"rules discussed in Chapter 4: Multiple mutable borrows to the same place can "
"cause data races and inconsistencies. But being able to mutate data is very "
"useful! In the next section, we’ll discuss the interior mutability pattern "
"and the `RefCell<T>` type that you can use in conjunction with an `Rc<T>` to "
"work with this immutability restriction."
msgstr ""
