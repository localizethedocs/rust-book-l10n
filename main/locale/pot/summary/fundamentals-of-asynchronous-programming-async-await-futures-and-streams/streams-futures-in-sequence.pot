msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch17-04-streams.md:3
msgid "<a id=\"streams\"></a>"
msgstr ""

#: src/ch17-04-streams.md:5
msgid "Streams: Futures in Sequence"
msgstr ""

#: src/ch17-04-streams.md:7
msgid ""
"Recall how we used the receiver for our async channel earlier in this "
"chapter in the [“Message Passing”](ch17-02-concurrency-with-async."
"html#message-passing)<!-- ignore --> section. The async `recv` method "
"produces a sequence of items over time. This is an instance of a much more "
"general pattern known as a _stream_. Many concepts are naturally represented "
"as streams: items becoming available in a queue, chunks of data being pulled "
"incrementally from the filesystem when the full data set is too large for "
"the computer’s memory, or data arriving over the network over time. Because "
"streams are futures, we can use them with any other kind of future and "
"combine them in interesting ways. For example, we can batch up events to "
"avoid triggering too many network calls, set timeouts on sequences of long-"
"running operations, or throttle user interface events to avoid doing "
"needless work."
msgstr ""

#: src/ch17-04-streams.md:19
msgid ""
"We saw a sequence of items back in Chapter 13, when we looked at the "
"Iterator trait in [“The Iterator Trait and the `next` Method”](ch13-02-"
"iterators.html#the-iterator-trait-and-the-next-method)<!--\n"
"ignore --> section, but there are two differences between iterators and the "
"async channel receiver. The first difference is time: iterators are "
"synchronous, while the channel receiver is asynchronous. The second "
"difference is the API. When working directly with `Iterator`, we call its "
"synchronous `next` method. With the `trpl::Receiver` stream in particular, "
"we called an asynchronous `recv` method instead. Otherwise, these APIs feel "
"very similar, and that similarity isn’t a coincidence. A stream is like an "
"asynchronous form of iteration. Whereas the `trpl::Receiver` specifically "
"waits to receive messages, though, the general-purpose stream API is much "
"broader: it provides the next item the way `Iterator` does, but "
"asynchronously."
msgstr ""

#: src/ch17-04-streams.md:32
msgid ""
"The similarity between iterators and streams in Rust means we can actually "
"create a stream from any iterator. As with an iterator, we can work with a "
"stream by calling its `next` method and then awaiting the output, as in "
"Listing 17-21, which won’t compile yet."
msgstr ""

#: src/ch17-04-streams.md:40 src/ch17-04-streams.md:114
msgid "// required for mdbook test\n"
msgstr ""

#: src/ch17-04-streams.md:49 src/ch17-04-streams.md:126
msgid "\"The value was: {value}\""
msgstr ""

#: src/ch17-04-streams.md:57
msgid ""
"We start with an array of numbers, which we convert to an iterator and then "
"call `map` on to double all the values. Then we convert the iterator into a "
"stream using the `trpl::stream_from_iter` function. Next, we loop over the "
"items in the stream as they arrive with the `while let` loop."
msgstr ""

#: src/ch17-04-streams.md:62
msgid ""
"Unfortunately, when we try to run the code, it doesn’t compile but instead "
"reports that there’s no `next` method available:"
msgstr ""

#: src/ch17-04-streams.md:95
msgid ""
"As this output explains, the reason for the compiler error is that we need "
"the right trait in scope to be able to use the `next` method. Given our "
"discussion so far, you might reasonably expect that trait to be `Stream`, "
"but it’s actually `StreamExt`. Short for _extension_, `Ext` is a common "
"pattern in the Rust community for extending one trait with another."
msgstr ""

#: src/ch17-04-streams.md:101
msgid ""
"The `Stream` trait defines a low-level interface that effectively combines "
"the `Iterator` and `Future` traits. `StreamExt` supplies a higher-level set "
"of APIs on top of `Stream`, including the `next` method as well as other "
"utility methods similar to those provided by the `Iterator` trait. `Stream` "
"and `StreamExt` are not yet part of Rust’s standard library, but most "
"ecosystem crates use similar definitions."
msgstr ""

#: src/ch17-04-streams.md:108
msgid ""
"The fix to the compiler error is to add a `use` statement for `trpl::"
"StreamExt`, as in Listing 17-22."
msgstr ""

#: src/ch17-04-streams.md:121
msgid "// --snip--\n"
msgstr ""

#: src/ch17-04-streams.md:134
msgid ""
"With all those pieces put together, this code works the way we want! What’s "
"more, now that we have `StreamExt` in scope, we can use all of its utility "
"methods, just as with iterators."
msgstr ""
