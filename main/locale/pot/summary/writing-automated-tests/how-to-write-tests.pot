msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch11-01-writing-tests.md:1
msgid "How to Write Tests"
msgstr ""

#: src/ch11-01-writing-tests.md:3
msgid ""
"_Tests_ are Rust functions that verify that the non-test code is functioning "
"in the expected manner. The bodies of test functions typically perform these "
"three actions:"
msgstr ""

#: src/ch11-01-writing-tests.md:7
msgid "Set up any needed data or state."
msgstr ""

#: src/ch11-01-writing-tests.md:8
msgid "Run the code you want to test."
msgstr ""

#: src/ch11-01-writing-tests.md:9
msgid "Assert that the results are what you expect."
msgstr ""

#: src/ch11-01-writing-tests.md:11
msgid ""
"Let’s look at the features Rust provides specifically for writing tests that "
"take these actions, which include the `test` attribute, a few macros, and "
"the `should_panic` attribute."
msgstr ""

#: src/ch11-01-writing-tests.md:17
msgid "<a id=\"the-anatomy-of-a-test-function\"></a>"
msgstr ""

#: src/ch11-01-writing-tests.md:19
msgid "Structuring Test Functions"
msgstr ""

#: src/ch11-01-writing-tests.md:21
msgid ""
"At its simplest, a test in Rust is a function that’s annotated with the "
"`test` attribute. Attributes are metadata about pieces of Rust code; one "
"example is the `derive` attribute we used with structs in Chapter 5. To "
"change a function into a test function, add `#[test]` on the line before "
"`fn`. When you run your tests with the `cargo test` command, Rust builds a "
"test runner binary that runs the annotated functions and reports on whether "
"each test function passes or fails."
msgstr ""

#: src/ch11-01-writing-tests.md:29
msgid ""
"Whenever we make a new library project with Cargo, a test module with a test "
"function in it is automatically generated for us. This module gives you a "
"template for writing your tests so that you don’t have to look up the exact "
"structure and syntax every time you start a new project. You can add as many "
"additional test functions and as many test modules as you want!"
msgstr ""

#: src/ch11-01-writing-tests.md:35
msgid ""
"We’ll explore some aspects of how tests work by experimenting with the "
"template test before we actually test any code. Then, we’ll write some real-"
"world tests that call some code that we’ve written and assert that its "
"behavior is correct."
msgstr ""

#: src/ch11-01-writing-tests.md:39
msgid ""
"Let’s create a new library project called `adder` that will add two numbers:"
msgstr ""

#: src/ch11-01-writing-tests.md:47
msgid ""
"The contents of the _src/lib.rs_ file in your `adder` library should look "
"like Listing 11-1."
msgstr ""

#: src/ch11-01-writing-tests.md:82
msgid ""
"The file starts with an example `add` function so that we have something to "
"test."
msgstr ""

#: src/ch11-01-writing-tests.md:85
msgid ""
"For now, let’s focus solely on the `it_works` function. Note the `#[test]` "
"annotation: This attribute indicates this is a test function, so the test "
"runner knows to treat this function as a test. We might also have non-test "
"functions in the `tests` module to help set up common scenarios or perform "
"common operations, so we always need to indicate which functions are tests."
msgstr ""

#: src/ch11-01-writing-tests.md:91
msgid ""
"The example function body uses the `assert_eq!` macro to assert that "
"`result`, which contains the result of calling `add` with 2 and 2, equals 4. "
"This assertion serves as an example of the format for a typical test. Let’s "
"run it to see that this test passes."
msgstr ""

#: src/ch11-01-writing-tests.md:96
msgid ""
"The `cargo test` command runs all tests in our project, as shown in Listing "
"11-2."
msgstr ""

#: src/ch11-01-writing-tests.md:101
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-01ad14159ff659ab)\n"
"\n"
"running 1 test\n"
"test tests::it_works ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:122
msgid ""
"Cargo compiled and ran the test. We see the line `running 1 test`. The next "
"line shows the name of the generated test function, called `tests::"
"it_works`, and that the result of running that test is `ok`. The overall "
"summary `test result: ok.` means that all the tests passed, and the portion "
"that reads `1 passed; 0 failed` totals the number of tests that passed or "
"failed."
msgstr ""

#: src/ch11-01-writing-tests.md:128
msgid ""
"It’s possible to mark a test as ignored so that it doesn’t run in a "
"particular instance; we’ll cover that in the [“Ignoring Tests Unless "
"Specifically Requested”](ch11-02-running-tests.html#ignoring-tests-unless-"
"specifically-requested)<!-- ignore --> section later in this chapter. "
"Because we haven’t done that here, the summary shows `0 ignored`. We can "
"also pass an argument to the `cargo test` command to run only tests whose "
"name matches a string; this is called _filtering_, and we’ll cover it in the "
"[“Running a Subset of Tests by Name”](ch11-02-running-tests.html#running-a-"
"subset-of-tests-by-name)<!-- ignore --> section. Here, we haven’t filtered "
"the tests being run, so the end of the summary shows `0 filtered out`."
msgstr ""

#: src/ch11-01-writing-tests.md:137
msgid ""
"The `0 measured` statistic is for benchmark tests that measure performance. "
"Benchmark tests are, as of this writing, only available in nightly Rust. See "
"[the documentation about benchmark tests](../unstable-book/library-features/"
"test.html) to learn more."
msgstr ""

#: src/ch11-01-writing-tests.md:141
msgid ""
"The next part of the test output starting at `Doc-tests adder` is for the "
"results of any documentation tests. We don’t have any documentation tests "
"yet, but Rust can compile any code examples that appear in our API "
"documentation. This feature helps keep your docs and your code in sync! "
"We’ll discuss how to write documentation tests in the [“Documentation "
"Comments as Tests”](ch14-02-publishing-to-crates-io.html#documentation-"
"comments-as-tests)<!-- ignore --> section of Chapter 14. For now, we’ll "
"ignore the `Doc-tests` output."
msgstr ""

#: src/ch11-01-writing-tests.md:149
msgid ""
"Let’s start to customize the test to our own needs. First, change the name "
"of the `it_works` function to a different name, such as `exploration`, like "
"so:"
msgstr ""

#: src/ch11-01-writing-tests.md:152 src/ch11-01-writing-tests.md:396
#: src/ch11-01-writing-tests.md:724
msgid "<span class=\"filename\">Filename: src/lib.rs</span>"
msgstr ""

#: src/ch11-01-writing-tests.md:171
msgid ""
"Then, run `cargo test` again. The output now shows `exploration` instead of "
"`it_works`:"
msgstr ""

#: src/ch11-01-writing-tests.md:174
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::exploration ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:193
msgid ""
"Now we’ll add another test, but this time we’ll make a test that fails! "
"Tests fail when something in the test function panics. Each test is run in a "
"new thread, and when the main thread sees that a test thread has died, the "
"test is marked as failed. In Chapter 9, we talked about how the simplest way "
"to panic is to call the `panic!` macro. Enter the new test as a function "
"named `another`, so your _src/lib.rs_ file looks like Listing 11-3."
msgstr ""

#: src/ch11-01-writing-tests.md:219
msgid "\"Make this test fail\""
msgstr ""

#: src/ch11-01-writing-tests.md:226
msgid ""
"Run the tests again using `cargo test`. The output should look like Listing "
"11-4, which shows that our `exploration` test passed and `another` failed."
msgstr ""

#: src/ch11-01-writing-tests.md:231
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 2 tests\n"
"test tests::another ... FAILED\n"
"test tests::exploration ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::another stdout ----\n"
"\n"
"thread 'tests::another' panicked at src/lib.rs:17:9:\n"
"Make this test fail\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::another\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:265
msgid ""
"Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new "
"sections appear between the individual results and the summary: The first "
"displays the detailed reason for each test failure. In this case, we get the "
"details that `tests::another` failed because it panicked with the message "
"`Make this test fail` on line 17 in the _src/lib.rs_ file. The next section "
"lists just the names of all the failing tests, which is useful when there "
"are lots of tests and lots of detailed failing test output. We can use the "
"name of a failing test to run just that test to debug it more easily; we’ll "
"talk more about ways to run tests in the [“Controlling How Tests Are Run”]"
"(ch11-02-running-tests.html#controlling-how-tests-are-run)<!-- ignore --> "
"section."
msgstr ""

#: src/ch11-01-writing-tests.md:276
msgid ""
"The summary line displays at the end: Overall, our test result is `FAILED`. "
"We had one test pass and one test fail."
msgstr ""

#: src/ch11-01-writing-tests.md:279
msgid ""
"Now that you’ve seen what the test results look like in different scenarios, "
"let’s look at some macros other than `panic!` that are useful in tests."
msgstr ""

#: src/ch11-01-writing-tests.md:284
msgid "<a id=\"checking-results-with-the-assert-macro\"></a>"
msgstr ""

#: src/ch11-01-writing-tests.md:286
msgid "Checking Results with `assert!`"
msgstr ""

#: src/ch11-01-writing-tests.md:288
msgid ""
"The `assert!` macro, provided by the standard library, is useful when you "
"want to ensure that some condition in a test evaluates to `true`. We give "
"the `assert!` macro an argument that evaluates to a Boolean. If the value is "
"`true`, nothing happens and the test passes. If the value is `false`, the "
"`assert!` macro calls `panic!` to cause the test to fail. Using the `assert!"
"` macro helps us check that our code is functioning in the way we intend."
msgstr ""

#: src/ch11-01-writing-tests.md:295
msgid ""
"In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold` "
"method, which are repeated here in Listing 11-5. Let’s put this code in the "
"_src/lib.rs_ file, then write some tests for it using the `assert!` macro."
msgstr ""

#: src/ch11-01-writing-tests.md:317
msgid ""
"The `can_hold` method returns a Boolean, which means it’s a perfect use case "
"for the `assert!` macro. In Listing 11-6, we write a test that exercises the "
"`can_hold` method by creating a `Rectangle` instance that has a width of 8 "
"and a height of 7 and asserting that it can hold another `Rectangle` "
"instance that has a width of 5 and a height of 1."
msgstr ""

#: src/ch11-01-writing-tests.md:360
msgid ""
"Note the `use super::*;` line inside the `tests` module. The `tests` module "
"is a regular module that follows the usual visibility rules we covered in "
"Chapter 7 in the [“Paths for Referring to an Item in the Module Tree”]"
"(ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)<!-- ignore "
"--> section. Because the `tests` module is an inner module, we need to bring "
"the code under test in the outer module into the scope of the inner module. "
"We use a glob here, so anything we define in the outer module is available "
"to this `tests` module."
msgstr ""

#: src/ch11-01-writing-tests.md:369
msgid ""
"We’ve named our test `larger_can_hold_smaller`, and we’ve created the two "
"`Rectangle` instances that we need. Then, we called the `assert!` macro and "
"passed it the result of calling `larger.can_hold(&smaller)`. This expression "
"is supposed to return `true`, so our test should pass. Let’s find out!"
msgstr ""

#: src/ch11-01-writing-tests.md:374
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 1 test\n"
"test tests::larger_can_hold_smaller ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:393
msgid ""
"It does pass! Let’s add another test, this time asserting that a smaller "
"rectangle cannot hold a larger rectangle:"
msgstr ""

#: src/ch11-01-writing-tests.md:417 src/ch11-01-writing-tests.md:481
#: src/ch11-01-writing-tests.md:932 src/ch11-01-writing-tests.md:999
msgid "// --snip--\n"
msgstr ""

#: src/ch11-01-writing-tests.md:446
msgid ""
"Because the correct result of the `can_hold` function in this case is "
"`false`, we need to negate that result before we pass it to the `assert!` "
"macro. As a result, our test will pass if `can_hold` returns `false`:"
msgstr ""

#: src/ch11-01-writing-tests.md:450
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... ok\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests rectangle\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:470
msgid ""
"Two tests that pass! Now let’s see what happens to our test results when we "
"introduce a bug in our code. We’ll change the implementation of the "
"`can_hold` method by replacing the greater-than sign (`>`) with a less-than "
"sign (`<`) when it compares the widths:"
msgstr ""

#: src/ch11-01-writing-tests.md:523
msgid "Running the tests now produces the following:"
msgstr ""

#: src/ch11-01-writing-tests.md:525
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"rectangle-6584c4561e48942e)\n"
"\n"
"running 2 tests\n"
"test tests::larger_can_hold_smaller ... FAILED\n"
"test tests::smaller_cannot_hold_larger ... ok\n"
"\n"
"failures:\n"
"\n"
"---- tests::larger_can_hold_smaller stdout ----\n"
"\n"
"thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\n"
"assertion failed: larger.can_hold(&smaller)\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::larger_can_hold_smaller\n"
"\n"
"test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:552
msgid ""
"Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` "
"is `5`, the comparison of the widths in `can_hold` now returns `false`: 8 is "
"not less than 5."
msgstr ""

#: src/ch11-01-writing-tests.md:558
msgid "<a id=\"testing-equality-with-the-assert_eq-and-assert_ne-macros\"></a>"
msgstr ""

#: src/ch11-01-writing-tests.md:560
msgid "Testing Equality with `assert_eq!` and `assert_ne!`"
msgstr ""

#: src/ch11-01-writing-tests.md:562
msgid ""
"A common way to verify functionality is to test for equality between the "
"result of the code under test and the value you expect the code to return. "
"You could do this by using the `assert!` macro and passing it an expression "
"using the `==` operator. However, this is such a common test that the "
"standard library provides a pair of macros—`assert_eq!` and `assert_ne!`—to "
"perform this test more conveniently. These macros compare two arguments for "
"equality or inequality, respectively. They’ll also print the two values if "
"the assertion fails, which makes it easier to see _why_ the test failed; "
"conversely, the `assert!` macro only indicates that it got a `false` value "
"for the `==` expression, without printing the values that led to the `false` "
"value."
msgstr ""

#: src/ch11-01-writing-tests.md:573
msgid ""
"In Listing 11-7, we write a function named `add_two` that adds `2` to its "
"parameter, and then we test this function using the `assert_eq!` macro."
msgstr ""

#: src/ch11-01-writing-tests.md:597
msgid "Let’s check that it passes!"
msgstr ""

#: src/ch11-01-writing-tests.md:599
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests adder\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:618
msgid ""
"We create a variable named `result` that holds the result of calling "
"`add_two(2)`. Then, we pass `result` and `4` as the arguments to the "
"`assert_eq!` macro. The output line for this test is `test tests::"
"it_adds_two ... ok`, and the `ok` text indicates that our test passed!"
msgstr ""

#: src/ch11-01-writing-tests.md:623
msgid ""
"Let’s introduce a bug into our code to see what `assert_eq!` looks like when "
"it fails. Change the implementation of the `add_two` function to instead add "
"`3`:"
msgstr ""

#: src/ch11-01-writing-tests.md:643
msgid "Run the tests again:"
msgstr ""

#: src/ch11-01-writing-tests.md:645
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling adder v0.1.0 (file:///projects/adder)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"adder-92948b65e88960b4)\n"
"\n"
"running 1 test\n"
"test tests::it_adds_two ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::it_adds_two stdout ----\n"
"\n"
"thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:\n"
"assertion `left == right` failed\n"
"  left: 5\n"
" right: 4\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::it_adds_two\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:673
msgid ""
"Our test caught the bug! The `tests::it_adds_two` test failed, and the "
"message tells us that the assertion that failed was `left == right` and what "
"the `left` and `right` values are. This message helps us start debugging: "
"The `left` argument, where we had the result of calling `add_two(2)`, was "
"`5`, but the `right` argument was `4`. You can imagine that this would be "
"especially helpful when we have a lot of tests going on."
msgstr ""

#: src/ch11-01-writing-tests.md:680
msgid ""
"Note that in some languages and test frameworks, the parameters to equality "
"assertion functions are called `expected` and `actual`, and the order in "
"which we specify the arguments matters. However, in Rust, they’re called "
"`left` and `right`, and the order in which we specify the value we expect "
"and the value the code produces doesn’t matter. We could write the assertion "
"in this test as `assert_eq!(4, result)`, which would result in the same "
"failure message that displays ``assertion `left == right` failed``."
msgstr ""

#: src/ch11-01-writing-tests.md:688
msgid ""
"The `assert_ne!` macro will pass if the two values we give it are not equal "
"and will fail if they are equal. This macro is most useful for cases when "
"we’re not sure what a value _will_ be, but we know what the value definitely "
"_shouldn’t_ be. For example, if we’re testing a function that is guaranteed "
"to change its input in some way, but the way in which the input is changed "
"depends on the day of the week that we run our tests, the best thing to "
"assert might be that the output of the function is not equal to the input."
msgstr ""

#: src/ch11-01-writing-tests.md:696
msgid ""
"Under the surface, the `assert_eq!` and `assert_ne!` macros use the "
"operators `==` and `!=`, respectively. When the assertions fail, these "
"macros print their arguments using debug formatting, which means the values "
"being compared must implement the `PartialEq` and `Debug` traits. All "
"primitive types and most of the standard library types implement these "
"traits. For structs and enums that you define yourself, you’ll need to "
"implement `PartialEq` to assert equality of those types. You’ll also need to "
"implement `Debug` to print the values when the assertion fails. Because both "
"traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this "
"is usually as straightforward as adding the `#[derive(PartialEq, Debug)]` "
"annotation to your struct or enum definition. See Appendix C, [“Derivable "
"Traits,”](appendix-03-derivable-traits.html)<!-- ignore --> for more details "
"about these and other derivable traits."
msgstr ""

#: src/ch11-01-writing-tests.md:709
msgid "Adding Custom Failure Messages"
msgstr ""

#: src/ch11-01-writing-tests.md:711
msgid ""
"You can also add a custom message to be printed with the failure message as "
"optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. "
"Any arguments specified after the required arguments are passed along to the "
"`format!` macro (discussed in [“Concatenating with `+` or `format!`”]"
"(ch08-02-strings.html#concatenating-with--or-format)<!--\n"
"ignore --> in Chapter 8), so you can pass a format string that contains `{}` "
"placeholders and values to go in those placeholders. Custom messages are "
"useful for documenting what an assertion means; when a test fails, you’ll "
"have a better idea of what the problem is with the code."
msgstr ""

#: src/ch11-01-writing-tests.md:721
msgid ""
"For example, let’s say we have a function that greets people by name and we "
"want to test that the name we pass into the function appears in the output:"
msgstr ""

#: src/ch11-01-writing-tests.md:728
msgid "\"Hello {name}!\""
msgstr ""

#: src/ch11-01-writing-tests.md:737 src/ch11-01-writing-tests.md:738
#: src/ch11-01-writing-tests.md:764 src/ch11-01-writing-tests.md:765
#: src/ch11-01-writing-tests.md:815 src/ch11-01-writing-tests.md:817
msgid "\"Carol\""
msgstr ""

#: src/ch11-01-writing-tests.md:743
msgid ""
"The requirements for this program haven’t been agreed upon yet, and we’re "
"pretty sure the `Hello` text at the beginning of the greeting will change. "
"We decided we don’t want to have to update the test when the requirements "
"change, so instead of checking for exact equality to the value returned from "
"the `greeting` function, we’ll just assert that the output contains the text "
"of the input parameter."
msgstr ""

#: src/ch11-01-writing-tests.md:750
msgid ""
"Now let’s introduce a bug into this code by changing `greeting` to exclude "
"`name` to see what the default test failure looks like:"
msgstr ""

#: src/ch11-01-writing-tests.md:755 src/ch11-01-writing-tests.md:806
msgid "\"Hello!\""
msgstr ""

#: src/ch11-01-writing-tests.md:770
msgid "Running this test produces the following:"
msgstr ""

#: src/ch11-01-writing-tests.md:772
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"\n"
"thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\n"
"assertion failed: result.contains(\"Carol\")\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:798
msgid ""
"This result just indicates that the assertion failed and which line the "
"assertion is on. A more useful failure message would print the value from "
"the `greeting` function. Let’s add a custom failure message composed of a "
"format string with a placeholder filled in with the actual value we got from "
"the `greeting` function:"
msgstr ""

#: src/ch11-01-writing-tests.md:818
msgid "\"Greeting did not contain name, value was `{result}`\""
msgstr ""

#: src/ch11-01-writing-tests.md:824
msgid "Now when we run the test, we’ll get a more informative error message:"
msgstr ""

#: src/ch11-01-writing-tests.md:826
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling greeter v0.1.0 (file:///projects/greeter)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"greeter-170b942eb5bf5e3a)\n"
"\n"
"running 1 test\n"
"test tests::greeting_contains_name ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greeting_contains_name stdout ----\n"
"\n"
"thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\n"
"Greeting did not contain name, value was `Hello!`\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"\n"
"\n"
"failures:\n"
"    tests::greeting_contains_name\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:852
msgid ""
"We can see the value we actually got in the test output, which would help us "
"debug what happened instead of what we were expecting to happen."
msgstr ""

#: src/ch11-01-writing-tests.md:855
msgid "Checking for Panics with `should_panic`"
msgstr ""

#: src/ch11-01-writing-tests.md:857
msgid ""
"In addition to checking return values, it’s important to check that our code "
"handles error conditions as we expect. For example, consider the `Guess` "
"type that we created in Chapter 9, Listing 9-13. Other code that uses "
"`Guess` depends on the guarantee that `Guess` instances will contain only "
"values between 1 and 100. We can write a test that ensures that attempting "
"to create a `Guess` instance with a value outside that range panics."
msgstr ""

#: src/ch11-01-writing-tests.md:864
msgid ""
"We do this by adding the attribute `should_panic` to our test function. The "
"test passes if the code inside the function panics; the test fails if the "
"code inside the function doesn’t panic."
msgstr ""

#: src/ch11-01-writing-tests.md:868
msgid ""
"Listing 11-8 shows a test that checks that the error conditions of `Guess::"
"new` happen when we expect them to."
msgstr ""

#: src/ch11-01-writing-tests.md:881 src/ch11-01-writing-tests.md:937
msgid "\"Guess value must be between 1 and 100, got {value}.\""
msgstr ""

#: src/ch11-01-writing-tests.md:902
msgid ""
"We place the `#[should_panic]` attribute after the `#[test]` attribute and "
"before the test function it applies to. Let’s look at the result when this "
"test passes:"
msgstr ""

#: src/ch11-01-writing-tests.md:906
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... ok\n"
"\n"
"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"   Doc-tests guessing_game\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; "
"finished in 0.00s\n"
"\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:925
msgid ""
"Looks good! Now let’s introduce a bug in our code by removing the condition "
"that the `new` function will panic if the value is greater than 100:"
msgstr ""

#: src/ch11-01-writing-tests.md:956
msgid "When we run the test in Listing 11-8, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:958
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"note: test did not panic as expected at src/lib.rs:21:8\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:980
msgid ""
"We don’t get a very helpful message in this case, but when we look at the "
"test function, we see that it’s annotated with `#[should_panic]`. The "
"failure we got means that the code in the test function did not cause a "
"panic."
msgstr ""

#: src/ch11-01-writing-tests.md:984
msgid ""
"Tests that use `should_panic` can be imprecise. A `should_panic` test would "
"pass even if the test panics for a different reason from the one we were "
"expecting. To make `should_panic` tests more precise, we can add an optional "
"`expected` parameter to the `should_panic` attribute. The test harness will "
"make sure that the failure message contains the provided text. For example, "
"consider the modified code for `Guess` in Listing 11-9 where the `new` "
"function panics with different messages depending on whether the value is "
"too small or too large."
msgstr ""

#: src/ch11-01-writing-tests.md:1006 src/ch11-01-writing-tests.md:1058
msgid "\"Guess value must be greater than or equal to 1, got {value}.\""
msgstr ""

#: src/ch11-01-writing-tests.md:1010 src/ch11-01-writing-tests.md:1054
msgid "\"Guess value must be less than or equal to 100, got {value}.\""
msgstr ""

#: src/ch11-01-writing-tests.md:1023 src/ch11-01-writing-tests.md:1071
msgid "\"less than or equal to 100\""
msgstr ""

#: src/ch11-01-writing-tests.md:1032
msgid ""
"This test will pass because the value we put in the `should_panic` "
"attribute’s `expected` parameter is a substring of the message that the "
"`Guess::new` function panics with. We could have specified the entire panic "
"message that we expect, which in this case would be `Guess value must be "
"less than or equal to 100, got 200`. What you choose to specify depends on "
"how much of the panic message is unique or dynamic and how precise you want "
"your test to be. In this case, a substring of the panic message is enough to "
"ensure that the code in the test function executes the `else if value > 100` "
"case."
msgstr ""

#: src/ch11-01-writing-tests.md:1041
msgid ""
"To see what happens when a `should_panic` test with an `expected` message "
"fails, let’s again introduce a bug into our code by swapping the bodies of "
"the `if value < 1` and the `else if value > 100` blocks:"
msgstr ""

#: src/ch11-01-writing-tests.md:1078
msgid "This time when we run the `should_panic` test, it will fail:"
msgstr ""

#: src/ch11-01-writing-tests.md:1080
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n"
"    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n"
"     Running unittests src/lib.rs (target/debug/deps/"
"guessing_game-57d70c3acb738f4d)\n"
"\n"
"running 1 test\n"
"test tests::greater_than_100 - should panic ... FAILED\n"
"\n"
"failures:\n"
"\n"
"---- tests::greater_than_100 stdout ----\n"
"\n"
"thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\n"
"Guess value must be greater than or equal to 1, got 200.\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"note: panic did not contain expected string\n"
"      panic message: \"Guess value must be greater than or equal to 1, got "
"200.\"\n"
" expected substring: \"less than or equal to 100\"\n"
"\n"
"failures:\n"
"    tests::greater_than_100\n"
"\n"
"test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered "
"out; finished in 0.00s\n"
"\n"
"error: test failed, to rerun pass `--lib`\n"
"```"
msgstr ""

#: src/ch11-01-writing-tests.md:1108
msgid ""
"The failure message indicates that this test did indeed panic as we "
"expected, but the panic message did not include the expected string `less "
"than or equal to 100`. The panic message that we did get in this case was "
"`Guess value must be greater than or equal to 1, got 200`. Now we can start "
"figuring out where our bug is!"
msgstr ""

#: src/ch11-01-writing-tests.md:1114
msgid "Using `Result<T, E>` in Tests"
msgstr ""

#: src/ch11-01-writing-tests.md:1116
msgid ""
"All of our tests so far panic when they fail. We can also write tests that "
"use `Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use "
"`Result<T, E>` and return an `Err` instead of panicking:"
msgstr ""

#: src/ch11-01-writing-tests.md:1136
msgid "\"two plus two does not equal four\""
msgstr ""

#: src/ch11-01-writing-tests.md:1142
msgid ""
"The `it_works` function now has the `Result<(), String>` return type. In the "
"body of the function, rather than calling the `assert_eq!` macro, we return "
"`Ok(())` when the test passes and an `Err` with a `String` inside when the "
"test fails."
msgstr ""

#: src/ch11-01-writing-tests.md:1147
msgid ""
"Writing tests so that they return a `Result<T, E>` enables you to use the "
"question mark operator in the body of tests, which can be a convenient way "
"to write tests that should fail if any operation within them returns an "
"`Err` variant."
msgstr ""

#: src/ch11-01-writing-tests.md:1152
msgid ""
"You can’t use the `#[should_panic]` annotation on tests that use `Result<T, "
"E>`. To assert that an operation returns an `Err` variant, _don’t_ use the "
"question mark operator on the `Result<T, E>` value. Instead, use `assert!"
"(value.is_err())`."
msgstr ""

#: src/ch11-01-writing-tests.md:1157
msgid ""
"Now that you know several ways to write tests, let’s look at what is "
"happening when we run our tests and explore the different options we can use "
"with `cargo test`."
msgstr ""
