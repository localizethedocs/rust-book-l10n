msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch16-04-extensible-concurrency-sync-and-send.md:3
msgid ""
"<a id=\"extensible-concurrency-with-the-sync-and-send-traits\"></a> <a "
"id=\"extensible-concurrency-with-the-send-and-sync-traits\"></a>"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:6
msgid "Extensible Concurrency with `Send` and `Sync`"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:8
msgid ""
"Interestingly, almost every concurrency feature we’ve talked about so far in "
"this chapter has been part of the standard library, not the language. Your "
"options for handling concurrency are not limited to the language or the "
"standard library; you can write your own concurrency features or use those "
"written by others."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:14
msgid ""
"However, among the key concurrency concepts that are embedded in the "
"language rather than the standard library are the `std::marker` traits "
"`Send` and `Sync`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:19
msgid ""
"<a id=\"allowing-transference-of-ownership-between-threads-with-send\"></a>"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:21
msgid "Transferring Ownership Between Threads"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:23
msgid ""
"The `Send` marker trait indicates that ownership of values of the type "
"implementing `Send` can be transferred between threads. Almost every Rust "
"type implements `Send`, but there are some exceptions, including `Rc<T>`: "
"This cannot implement `Send` because if you cloned an `Rc<T>` value and "
"tried to transfer ownership of the clone to another thread, both threads "
"might update the reference count at the same time. For this reason, `Rc<T>` "
"is implemented for use in single-threaded situations where you don’t want to "
"pay the thread-safe performance penalty."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:32
msgid ""
"Therefore, Rust’s type system and trait bounds ensure that you can never "
"accidentally send an `Rc<T>` value across threads unsafely. When we tried to "
"do this in Listing 16-14, we got the error `` the trait `Send` is not "
"implemented for `Rc<Mutex<i32>>` ``. When we switched to `Arc<T>`, which "
"does implement `Send`, the code compiled."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:38
msgid ""
"Any type composed entirely of `Send` types is automatically marked as `Send` "
"as well. Almost all primitive types are `Send`, aside from raw pointers, "
"which we’ll discuss in Chapter 20."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:44
msgid "<a id=\"allowing-access-from-multiple-threads-with-sync\"></a>"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:46
msgid "Accessing from Multiple Threads"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:48
msgid ""
"The `Sync` marker trait indicates that it is safe for the type implementing "
"`Sync` to be referenced from multiple threads. In other words, any type `T` "
"implements `Sync` if `&T` (an immutable reference to `T`) implements `Send`, "
"meaning the reference can be sent safely to another thread. Similar to "
"`Send`, primitive types all implement `Sync`, and types composed entirely of "
"types that implement `Sync` also implement `Sync`."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:55
msgid ""
"The smart pointer `Rc<T>` also doesn’t implement `Sync` for the same reasons "
"that it doesn’t implement `Send`. The `RefCell<T>` type (which we talked "
"about in Chapter 15) and the family of related `Cell<T>` types don’t "
"implement `Sync`. The implementation of borrow checking that `RefCell<T>` "
"does at runtime is not thread-safe. The smart pointer `Mutex<T>` implements "
"`Sync` and can be used to share access with multiple threads, as you saw in "
"[“Shared Access to `Mutex<T>`”](ch16-03-shared-state.html#shared-access-to-"
"mutext)<!-- ignore -->."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:63
msgid "Implementing `Send` and `Sync` Manually Is Unsafe"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:65
msgid ""
"Because types composed entirely of other types that implement the `Send` and "
"`Sync` traits also automatically implement `Send` and `Sync`, we don’t have "
"to implement those traits manually. As marker traits, they don’t even have "
"any methods to implement. They’re just useful for enforcing invariants "
"related to concurrency."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:71
msgid ""
"Manually implementing these traits involves implementing unsafe Rust code. "
"We’ll talk about using unsafe Rust code in Chapter 20; for now, the "
"important information is that building new concurrent types not made up of "
"`Send` and `Sync` parts requires careful thought to uphold the safety "
"guarantees. [“The Rustonomicon”](../nomicon/index.html) has more information "
"about these guarantees and how to uphold them."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:78
msgid "Summary"
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:80
msgid ""
"This isn’t the last you’ll see of concurrency in this book: The next chapter "
"focuses on async programming, and the project in Chapter 21 will use the "
"concepts in this chapter in a more realistic situation than the smaller "
"examples discussed here."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:85
msgid ""
"As mentioned earlier, because very little of how Rust handles concurrency is "
"part of the language, many concurrency solutions are implemented as crates. "
"These evolve more quickly than the standard library, so be sure to search "
"online for the current, state-of-the-art crates to use in multithreaded "
"situations."
msgstr ""

#: src/ch16-04-extensible-concurrency-sync-and-send.md:91
msgid ""
"The Rust standard library provides channels for message passing and smart "
"pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in "
"concurrent contexts. The type system and the borrow checker ensure that the "
"code using these solutions won’t end up with data races or invalid "
"references. Once you get your code to compile, you can rest assured that it "
"will happily run on multiple threads without the kinds of hard-to-track-down "
"bugs common in other languages. Concurrent programming is no longer a "
"concept to be afraid of: Go forth and make your programs concurrent, "
"fearlessly!"
msgstr ""
