msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch16-03-shared-state.md:1
msgid "Shared-State Concurrency"
msgstr ""

#: src/ch16-03-shared-state.md:3
msgid ""
"Message passing is a fine way to handle concurrency, but it’s not the only "
"way. Another method would be for multiple threads to access the same shared "
"data. Consider this part of the slogan from the Go language documentation "
"again: “Do not communicate by sharing memory.”"
msgstr ""

#: src/ch16-03-shared-state.md:8
msgid ""
"What would communicating by sharing memory look like? In addition, why would "
"message-passing enthusiasts caution not to use memory sharing?"
msgstr ""

#: src/ch16-03-shared-state.md:11
msgid ""
"In a way, channels in any programming language are similar to single "
"ownership because once you transfer a value down a channel, you should no "
"longer use that value. Shared-memory concurrency is like multiple ownership: "
"Multiple threads can access the same memory location at the same time. As "
"you saw in Chapter 15, where smart pointers made multiple ownership "
"possible, multiple ownership can add complexity because these different "
"owners need managing. Rust’s type system and ownership rules greatly assist "
"in getting this management correct. For an example, let’s look at mutexes, "
"one of the more common concurrency primitives for shared memory."
msgstr ""

#: src/ch16-03-shared-state.md:23
msgid ""
"<a id=\"using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time\"></"
"a>"
msgstr ""

#: src/ch16-03-shared-state.md:25
msgid "Controlling Access with Mutexes"
msgstr ""

#: src/ch16-03-shared-state.md:27
msgid ""
"_Mutex_ is an abbreviation for _mutual exclusion_, as in a mutex allows only "
"one thread to access some data at any given time. To access the data in a "
"mutex, a thread must first signal that it wants access by asking to acquire "
"the mutex’s lock. The _lock_ is a data structure that is part of the mutex "
"that keeps track of who currently has exclusive access to the data. "
"Therefore, the mutex is described as _guarding_ the data it holds via the "
"locking system."
msgstr ""

#: src/ch16-03-shared-state.md:34
msgid ""
"Mutexes have a reputation for being difficult to use because you have to "
"remember two rules:"
msgstr ""

#: src/ch16-03-shared-state.md:37
msgid "You must attempt to acquire the lock before using the data."
msgstr ""

#: src/ch16-03-shared-state.md:38
msgid ""
"When you’re done with the data that the mutex guards, you must unlock the "
"data so that other threads can acquire the lock."
msgstr ""

#: src/ch16-03-shared-state.md:41
msgid ""
"For a real-world metaphor for a mutex, imagine a panel discussion at a "
"conference with only one microphone. Before a panelist can speak, they have "
"to ask or signal that they want to use the microphone. When they get the "
"microphone, they can talk for as long as they want to and then hand the "
"microphone to the next panelist who requests to speak. If a panelist forgets "
"to hand the microphone off when they’re finished with it, no one else is "
"able to speak. If management of the shared microphone goes wrong, the panel "
"won’t work as planned!"
msgstr ""

#: src/ch16-03-shared-state.md:50
msgid ""
"Management of mutexes can be incredibly tricky to get right, which is why so "
"many people are enthusiastic about channels. However, thanks to Rust’s type "
"system and ownership rules, you can’t get locking and unlocking wrong."
msgstr ""

#: src/ch16-03-shared-state.md:54
msgid "The API of `Mutex<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:56
msgid ""
"As an example of how to use a mutex, let’s start by using a mutex in a "
"single-threaded context, as shown in Listing 16-12."
msgstr ""

#: src/ch16-03-shared-state.md:72
msgid "\"m = {m:?}\""
msgstr ""

#: src/ch16-03-shared-state.md:78
msgid ""
"As with many types, we create a `Mutex<T>` using the associated function "
"`new`. To access the data inside the mutex, we use the `lock` method to "
"acquire the lock. This call will block the current thread so that it can’t "
"do any work until it’s our turn to have the lock."
msgstr ""

#: src/ch16-03-shared-state.md:83
msgid ""
"The call to `lock` would fail if another thread holding the lock panicked. "
"In that case, no one would ever be able to get the lock, so we’ve chosen to "
"`unwrap` and have this thread panic if we’re in that situation."
msgstr ""

#: src/ch16-03-shared-state.md:87
msgid ""
"After we’ve acquired the lock, we can treat the return value, named `num` in "
"this case, as a mutable reference to the data inside. The type system "
"ensures that we acquire a lock before using the value in `m`. The type of "
"`m` is `Mutex<i32>`, not `i32`, so we _must_ call `lock` to be able to use "
"the `i32` value. We can’t forget; the type system won’t let us access the "
"inner `i32` otherwise."
msgstr ""

#: src/ch16-03-shared-state.md:94
msgid ""
"The call to `lock` returns a type called `MutexGuard`, wrapped in a "
"`LockResult` that we handled with the call to `unwrap`. The `MutexGuard` "
"type implements `Deref` to point at our inner data; the type also has a "
"`Drop` implementation that releases the lock automatically when a "
"`MutexGuard` goes out of scope, which happens at the end of the inner scope. "
"As a result, we don’t risk forgetting to release the lock and blocking the "
"mutex from being used by other threads because the lock release happens "
"automatically."
msgstr ""

#: src/ch16-03-shared-state.md:102
msgid ""
"After dropping the lock, we can print the mutex value and see that we were "
"able to change the inner `i32` to `6`."
msgstr ""

#: src/ch16-03-shared-state.md:107
msgid "<a id=\"sharing-a-mutext-between-multiple-threads\"></a>"
msgstr ""

#: src/ch16-03-shared-state.md:109
msgid "Shared Access to `Mutex<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:111
msgid ""
"Now let’s try to share a value between multiple threads using `Mutex<T>`. "
"We’ll spin up 10 threads and have them each increment a counter value by 1, "
"so the counter goes from 0 to 10. The example in Listing 16-13 will have a "
"compiler error, and we’ll use that error to learn more about using "
"`Mutex<T>` and how Rust helps us use it correctly."
msgstr ""

#: src/ch16-03-shared-state.md:140 src/ch16-03-shared-state.md:227
#: src/ch16-03-shared-state.md:328
msgid "\"Result: {}\""
msgstr ""

#: src/ch16-03-shared-state.md:146
msgid ""
"We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we "
"did in Listing 16-12. Next, we create 10 threads by iterating over a range "
"of numbers. We use `thread::spawn` and give all the threads the same "
"closure: one that moves the counter into the thread, acquires a lock on the "
"`Mutex<T>` by calling the `lock` method, and then adds 1 to the value in the "
"mutex. When a thread finishes running its closure, `num` will go out of "
"scope and release the lock so that another thread can acquire it."
msgstr ""

#: src/ch16-03-shared-state.md:154
msgid ""
"In the main thread, we collect all the join handles. Then, as we did in "
"Listing 16-2, we call `join` on each handle to make sure all the threads "
"finish. At that point, the main thread will acquire the lock and print the "
"result of this program."
msgstr ""

#: src/ch16-03-shared-state.md:159
msgid "We hinted that this example wouldn’t compile. Now let’s find out why!"
msgstr ""

#: src/ch16-03-shared-state.md:161
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0382]: borrow of moved value: `counter`\n"
"  --> src/main.rs:21:29\n"
"   |\n"
" 5 |     let counter = Mutex::new(0);\n"
"   |         ------- move occurs because `counter` has type `std::sync::"
"Mutex<i32>`, which does not implement the `Copy` trait\n"
"...\n"
" 8 |     for _ in 0..10 {\n"
"   |     -------------- inside of this loop\n"
" 9 |         let handle = thread::spawn(move || {\n"
"   |                                    ------- value moved into closure "
"here, in previous iteration of loop\n"
"...\n"
"21 |     println!(\"Result: {}\", *counter.lock().unwrap());\n"
"   |                             ^^^^^^^ value borrowed here after move\n"
"   |\n"
"help: consider moving the expression out of the loop so it is only moved "
"once\n"
"   |\n"
" 8 ~     let mut value = counter.lock();\n"
" 9 ~     for _ in 0..10 {\n"
"10 |         let handle = thread::spawn(move || {\n"
"11 ~             let mut num = value.unwrap();\n"
"   |\n"
"\n"
"For more information about this error, try `rustc --explain E0382`.\n"
"error: could not compile `shared-state` (bin \"shared-state\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:190
msgid ""
"The error message states that the `counter` value was moved in the previous "
"iteration of the loop. Rust is telling us that we can’t move the ownership "
"of lock `counter` into multiple threads. Let’s fix the compiler error with "
"the multiple-ownership method we discussed in Chapter 15."
msgstr ""

#: src/ch16-03-shared-state.md:195
msgid "Multiple Ownership with Multiple Threads"
msgstr ""

#: src/ch16-03-shared-state.md:197
msgid ""
"In Chapter 15, we gave a value to multiple owners by using the smart pointer "
"`Rc<T>` to create a reference-counted value. Let’s do the same here and see "
"what happens. We’ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and "
"clone the `Rc<T>` before moving ownership to the thread."
msgstr ""

#: src/ch16-03-shared-state.md:233
msgid ""
"Once again, we compile and get... different errors! The compiler is teaching "
"us a lot:"
msgstr ""

#: src/ch16-03-shared-state.md:236
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling shared-state v0.1.0 (file:///projects/shared-state)\n"
"error[E0277]: `Rc<std::sync::Mutex<i32>>` cannot be sent between threads "
"safely\n"
"  --> src/main.rs:11:36\n"
"   |\n"
"11 |           let handle = thread::spawn(move || {\n"
"   |                        ------------- ^------\n"
"   |                        |             |\n"
"   |  ______________________|_____________within this `{closure@src/main."
"rs:11:36: 11:43}`\n"
"   | |                      |\n"
"   | |                      required by a bound introduced by this call\n"
"12 | |             let mut num = counter.lock().unwrap();\n"
"13 | |\n"
"14 | |             *num += 1;\n"
"15 | |         });\n"
"   | |_________^ `Rc<std::sync::Mutex<i32>>` cannot be sent between threads "
"safely\n"
"   |\n"
"   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is "
"not implemented for `Rc<std::sync::Mutex<i32>>`\n"
"note: required because it's used within this closure\n"
"  --> src/main.rs:11:36\n"
"   |\n"
"11 |         let handle = thread::spawn(move || {\n"
"   |                                    ^^^^^^^\n"
"note: required by a bound in `spawn`\n"
"  --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/std/src/thread/"
"mod.rs:723:1\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `shared-state` (bin \"shared-state\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch16-03-shared-state.md:267
msgid ""
"Wow, that error message is very wordy! Here’s the important part to focus "
"on: `` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. The "
"compiler is also telling us the reason why: `` the trait `Send` is not "
"implemented for `Rc<Mutex<i32>>` ``. We’ll talk about `Send` in the next "
"section: It’s one of the traits that ensures that the types we use with "
"threads are meant for use in concurrent situations."
msgstr ""

#: src/ch16-03-shared-state.md:274
msgid ""
"Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>` "
"manages the reference count, it adds to the count for each call to `clone` "
"and subtracts from the count when each clone is dropped. But it doesn’t use "
"any concurrency primitives to make sure that changes to the count can’t be "
"interrupted by another thread. This could lead to wrong counts—subtle bugs "
"that could in turn lead to memory leaks or a value being dropped before "
"we’re done with it. What we need is a type that is exactly like `Rc<T>`, but "
"that makes changes to the reference count in a thread-safe way."
msgstr ""

#: src/ch16-03-shared-state.md:283
msgid "Atomic Reference Counting with `Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:285
msgid ""
"Fortunately, `Arc<T>` _is_ a type like `Rc<T>` that is safe to use in "
"concurrent situations. The _a_ stands for _atomic_, meaning it’s an "
"_atomically reference-counted_ type. Atomics are an additional kind of "
"concurrency primitive that we won’t cover in detail here: See the standard "
"library documentation for [`std::sync::atomic`](../std/sync/atomic/index."
"html)<!-- ignore --> for more details. At this point, you just need to know "
"that atomics work like primitive types but are safe to share across threads."
msgstr ""

#: src/ch16-03-shared-state.md:293
msgid ""
"You might then wonder why all primitive types aren’t atomic and why standard "
"library types aren’t implemented to use `Arc<T>` by default. The reason is "
"that thread safety comes with a performance penalty that you only want to "
"pay when you really need to. If you’re just performing operations on values "
"within a single thread, your code can run faster if it doesn’t have to "
"enforce the guarantees atomics provide."
msgstr ""

#: src/ch16-03-shared-state.md:300
msgid ""
"Let’s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we "
"fix our program by changing the `use` line, the call to `new`, and the call "
"to `clone`. The code in Listing 16-15 will finally compile and run."
msgstr ""

#: src/ch16-03-shared-state.md:334
msgid "This code will print the following:"
msgstr ""

#: src/ch16-03-shared-state.md:344
msgid ""
"We did it! We counted from 0 to 10, which may not seem very impressive, but "
"it did teach us a lot about `Mutex<T>` and thread safety. You could also use "
"this program’s structure to do more complicated operations than just "
"incrementing a counter. Using this strategy, you can divide a calculation "
"into independent parts, split those parts across threads, and then use a "
"`Mutex<T>` to have each thread update the final result with its part."
msgstr ""

#: src/ch16-03-shared-state.md:351
msgid ""
"Note that if you are doing simple numerical operations, there are types "
"simpler than `Mutex<T>` types provided by the [`std::sync::atomic` module of "
"the standard library](../std/sync/atomic/index.html)<!-- ignore -->. These "
"types provide safe, concurrent, atomic access to primitive types. We chose "
"to use `Mutex<T>` with a primitive type for this example so that we could "
"concentrate on how `Mutex<T>` works."
msgstr ""

#: src/ch16-03-shared-state.md:359
msgid "<a id=\"similarities-between-refcelltrct-and-mutextarct\"></a>"
msgstr ""

#: src/ch16-03-shared-state.md:361
msgid "Comparing `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`"
msgstr ""

#: src/ch16-03-shared-state.md:363
msgid ""
"You might have noticed that `counter` is immutable but that we could get a "
"mutable reference to the value inside it; this means `Mutex<T>` provides "
"interior mutability, as the `Cell` family does. In the same way we used "
"`RefCell<T>` in Chapter 15 to allow us to mutate contents inside an `Rc<T>`, "
"we use `Mutex<T>` to mutate contents inside an `Arc<T>`."
msgstr ""

#: src/ch16-03-shared-state.md:369
msgid ""
"Another detail to note is that Rust can’t protect you from all kinds of "
"logic errors when you use `Mutex<T>`. Recall from Chapter 15 that using "
"`Rc<T>` came with the risk of creating reference cycles, where two `Rc<T>` "
"values refer to each other, causing memory leaks. Similarly, `Mutex<T>` "
"comes with the risk of creating _deadlocks_. These occur when an operation "
"needs to lock two resources and two threads have each acquired one of the "
"locks, causing them to wait for each other forever. If you’re interested in "
"deadlocks, try creating a Rust program that has a deadlock; then, research "
"deadlock mitigation strategies for mutexes in any language and have a go at "
"implementing them in Rust. The standard library API documentation for "
"`Mutex<T>` and `MutexGuard` offers useful information."
msgstr ""

#: src/ch16-03-shared-state.md:381
msgid ""
"We’ll round out this chapter by talking about the `Send` and `Sync` traits "
"and how we can use them with custom types."
msgstr ""
