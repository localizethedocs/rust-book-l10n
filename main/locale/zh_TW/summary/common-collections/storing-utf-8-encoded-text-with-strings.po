msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch08-02-strings.md:1
msgid "Storing UTF-8 Encoded Text with Strings"
msgstr ""

#: src/ch08-02-strings.md:3
msgid ""
"We talked about strings in Chapter 4, but we’ll look at them in more depth "
"now. New Rustaceans commonly get stuck on strings for a combination of three "
"reasons: Rust’s propensity for exposing possible errors, strings being a "
"more complicated data structure than many programmers give them credit for, "
"and UTF-8. These factors combine in a way that can seem difficult when "
"you’re coming from other programming languages."
msgstr ""

#: src/ch08-02-strings.md:10
msgid ""
"We discuss strings in the context of collections because strings are "
"implemented as a collection of bytes, plus some methods to provide useful "
"functionality when those bytes are interpreted as text. In this section, "
"we’ll talk about the operations on `String` that every collection type has, "
"such as creating, updating, and reading. We’ll also discuss the ways in "
"which `String` is different from the other collections, namely, how indexing "
"into a `String` is complicated by the differences between how people and "
"computers interpret `String` data."
msgstr ""

#: src/ch08-02-strings.md:21
msgid "<a id=\"what-is-a-string\"></a>"
msgstr ""

#: src/ch08-02-strings.md:23
msgid "Defining Strings"
msgstr "定義字串"

#: src/ch08-02-strings.md:25
msgid ""
"We’ll first define what we mean by the term _string_. Rust has only one "
"string type in the core language, which is the string slice `str` that is "
"usually seen in its borrowed form, `&str`. In Chapter 4, we talked about "
"string slices, which are references to some UTF-8 encoded string data stored "
"elsewhere. String literals, for example, are stored in the program’s binary "
"and are therefore string slices."
msgstr ""

#: src/ch08-02-strings.md:32
msgid ""
"The `String` type, which is provided by Rust’s standard library rather than "
"coded into the core language, is a growable, mutable, owned, UTF-8 encoded "
"string type. When Rustaceans refer to “strings” in Rust, they might be "
"referring to either the `String` or the string slice `&str` types, not just "
"one of those types. Although this section is largely about `String`, both "
"types are used heavily in Rust’s standard library, and both `String` and "
"string slices are UTF-8 encoded."
msgstr ""

#: src/ch08-02-strings.md:40
msgid "Creating a New String"
msgstr ""

#: src/ch08-02-strings.md:42
msgid ""
"Many of the same operations available with `Vec<T>` are available with "
"`String` as well because `String` is actually implemented as a wrapper "
"around a vector of bytes with some extra guarantees, restrictions, and "
"capabilities. An example of a function that works the same way with `Vec<T>` "
"and `String` is the `new` function to create an instance, shown in Listing "
"8-11."
msgstr ""

#: src/ch08-02-strings.md:58
msgid ""
"This line creates a new, empty string called `s`, into which we can then "
"load data. Often, we’ll have some initial data with which we want to start "
"the string. For that, we use the `to_string` method, which is available on "
"any type that implements the `Display` trait, as string literals do. Listing "
"8-12 shows two examples."
msgstr ""

#: src/ch08-02-strings.md:68 src/ch08-02-strings.md:73
#: src/ch08-02-strings.md:89
msgid "\"initial contents\""
msgstr ""

#: src/ch08-02-strings.md:72
msgid "// The method also works on a literal directly:\n"
msgstr ""

#: src/ch08-02-strings.md:79
msgid "This code creates a string containing `initial contents`."
msgstr ""

#: src/ch08-02-strings.md:81
msgid ""
"We can also use the function `String::from` to create a `String` from a "
"string literal. The code in Listing 8-13 is equivalent to the code in "
"Listing 8-12 that uses `to_string`."
msgstr ""

#: src/ch08-02-strings.md:95
msgid ""
"Because strings are used for so many things, we can use many different "
"generic APIs for strings, providing us with a lot of options. Some of them "
"can seem redundant, but they all have their place! In this case, `String::"
"from` and `to_string` do the same thing, so which one you choose is a matter "
"of style and readability."
msgstr ""

#: src/ch08-02-strings.md:101
msgid ""
"Remember that strings are UTF-8 encoded, so we can include any properly "
"encoded data in them, as shown in Listing 8-14."
msgstr ""

#: src/ch08-02-strings.md:108 src/ch08-02-strings.md:334
#: src/ch08-02-strings.md:355
msgid "\"السلام عليكم\""
msgstr ""

#: src/ch08-02-strings.md:109 src/ch08-02-strings.md:335
#: src/ch08-02-strings.md:356
msgid "\"Dobrý den\""
msgstr ""

#: src/ch08-02-strings.md:110 src/ch08-02-strings.md:336
#: src/ch08-02-strings.md:357
msgid "\"Hello\""
msgstr ""

#: src/ch08-02-strings.md:111 src/ch08-02-strings.md:337
#: src/ch08-02-strings.md:358
msgid "\"שלום\""
msgstr ""

#: src/ch08-02-strings.md:112 src/ch08-02-strings.md:338
#: src/ch08-02-strings.md:359
msgid "\"नमस्ते\""
msgstr ""

#: src/ch08-02-strings.md:113 src/ch08-02-strings.md:339
#: src/ch08-02-strings.md:360
msgid "\"こんにちは\""
msgstr ""

#: src/ch08-02-strings.md:114 src/ch08-02-strings.md:340
#: src/ch08-02-strings.md:361
msgid "\"안녕하세요\""
msgstr ""

#: src/ch08-02-strings.md:115 src/ch08-02-strings.md:341
#: src/ch08-02-strings.md:362
msgid "\"你好\""
msgstr ""

#: src/ch08-02-strings.md:116 src/ch08-02-strings.md:342
#: src/ch08-02-strings.md:363
msgid "\"Olá\""
msgstr ""

#: src/ch08-02-strings.md:117 src/ch08-02-strings.md:343
#: src/ch08-02-strings.md:364 src/ch08-02-strings.md:377
#: src/ch08-02-strings.md:450
msgid "\"Здравствуйте\""
msgstr ""

#: src/ch08-02-strings.md:118 src/ch08-02-strings.md:344
#: src/ch08-02-strings.md:365
msgid "\"Hola\""
msgstr ""

#: src/ch08-02-strings.md:124
msgid "All of these are valid `String` values."
msgstr ""

#: src/ch08-02-strings.md:126
msgid "Updating a String"
msgstr ""

#: src/ch08-02-strings.md:128
msgid ""
"A `String` can grow in size and its contents can change, just like the "
"contents of a `Vec<T>`, if you push more data into it. In addition, you can "
"conveniently use the `+` operator or the `format!` macro to concatenate "
"`String` values."
msgstr ""

#: src/ch08-02-strings.md:134
msgid "<a id=\"appending-to-a-string-with-push_str-and-push\"></a>"
msgstr ""

#: src/ch08-02-strings.md:136
msgid "Appending with `push_str` or `push`"
msgstr ""

#: src/ch08-02-strings.md:138
msgid ""
"We can grow a `String` by using the `push_str` method to append a string "
"slice, as shown in Listing 8-15."
msgstr ""

#: src/ch08-02-strings.md:145 src/ch08-02-strings.md:161
msgid "\"foo\""
msgstr ""

#: src/ch08-02-strings.md:146 src/ch08-02-strings.md:162
msgid "\"bar\""
msgstr ""

#: src/ch08-02-strings.md:152
msgid ""
"After these two lines, `s` will contain `foobar`. The `push_str` method "
"takes a string slice because we don’t necessarily want to take ownership of "
"the parameter. For example, in the code in Listing 8-16, we want to be able "
"to use `s2` after appending its contents to `s1`."
msgstr ""

#: src/ch08-02-strings.md:164
msgid "\"s2 is {s2}\""
msgstr ""

#: src/ch08-02-strings.md:170
msgid ""
"If the `push_str` method took ownership of `s2`, we wouldn’t be able to "
"print its value on the last line. However, this code works as we’d expect!"
msgstr ""

#: src/ch08-02-strings.md:173
msgid ""
"The `push` method takes a single character as a parameter and adds it to the "
"`String`. Listing 8-17 adds the letter _l_ to a `String` using the `push` "
"method."
msgstr ""

#: src/ch08-02-strings.md:181
msgid "\"lo\""
msgstr ""

#: src/ch08-02-strings.md:182
msgid "'l'"
msgstr ""

#: src/ch08-02-strings.md:188
msgid "As a result, `s` will contain `lol`."
msgstr ""

#: src/ch08-02-strings.md:192
msgid "<a id=\"concatenation-with-the--operator-or-the-format-macro\"></a>"
msgstr ""

#: src/ch08-02-strings.md:194
msgid "Concatenating with `+` or `format!`"
msgstr ""

#: src/ch08-02-strings.md:196
msgid ""
"Often, you’ll want to combine two existing strings. One way to do so is to "
"use the `+` operator, as shown in Listing 8-18."
msgstr ""

#: src/ch08-02-strings.md:203
msgid "\"Hello, \""
msgstr ""

#: src/ch08-02-strings.md:204
msgid "\"world!\""
msgstr ""

#: src/ch08-02-strings.md:205
msgid "// note s1 has been moved here and can no longer be used\n"
msgstr ""

#: src/ch08-02-strings.md:211
msgid ""
"The string `s3` will contain `Hello, world!`. The reason `s1` is no longer "
"valid after the addition, and the reason we used a reference to `s2`, has to "
"do with the signature of the method that’s called when we use the `+` "
"operator. The `+` operator uses the `add` method, whose signature looks "
"something like this:"
msgstr ""

#: src/ch08-02-strings.md:221
msgid ""
"In the standard library, you’ll see `add` defined using generics and "
"associated types. Here, we’ve substituted in concrete types, which is what "
"happens when we call this method with `String` values. We’ll discuss "
"generics in Chapter 10. This signature gives us the clues we need in order "
"to understand the tricky bits of the `+` operator."
msgstr ""

#: src/ch08-02-strings.md:227
msgid ""
"First, `s2` has an `&`, meaning that we’re adding a reference of the second "
"string to the first string. This is because of the `s` parameter in the "
"`add` function: We can only add a string slice to a `String`; we can’t add "
"two `String` values together. But wait—the type of `&s2` is `&String`, not "
"`&str`, as specified in the second parameter to `add`. So, why does Listing "
"8-18 compile?"
msgstr ""

#: src/ch08-02-strings.md:234
msgid ""
"The reason we’re able to use `&s2` in the call to `add` is that the compiler "
"can coerce the `&String` argument into a `&str`. When we call the `add` "
"method, Rust uses a deref coercion, which here turns `&s2` into `&s2[..]`. "
"We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does "
"not take ownership of the `s` parameter, `s2` will still be a valid `String` "
"after this operation."
msgstr ""

#: src/ch08-02-strings.md:241
msgid ""
"Second, we can see in the signature that `add` takes ownership of `self` "
"because `self` does _not_ have an `&`. This means `s1` in Listing 8-18 will "
"be moved into the `add` call and will no longer be valid after that. So, "
"although `let s3 = s1 + &s2;` looks like it will copy both strings and "
"create a new one, this statement actually takes ownership of `s1`, appends a "
"copy of the contents of `s2`, and then returns ownership of the result. In "
"other words, it looks like it’s making a lot of copies, but it isn’t; the "
"implementation is more efficient than copying."
msgstr ""

#: src/ch08-02-strings.md:250
msgid ""
"If we need to concatenate multiple strings, the behavior of the `+` operator "
"gets unwieldy:"
msgstr ""

#: src/ch08-02-strings.md:255 src/ch08-02-strings.md:269
msgid "\"tic\""
msgstr ""

#: src/ch08-02-strings.md:256 src/ch08-02-strings.md:270
msgid "\"tac\""
msgstr ""

#: src/ch08-02-strings.md:257 src/ch08-02-strings.md:271
msgid "\"toe\""
msgstr ""

#: src/ch08-02-strings.md:259
msgid "\"-\""
msgstr ""

#: src/ch08-02-strings.md:263
msgid ""
"At this point, `s` will be `tic-tac-toe`. With all of the `+` and `\"` "
"characters, it’s difficult to see what’s going on. For combining strings in "
"more complicated ways, we can instead use the `format!` macro:"
msgstr ""

#: src/ch08-02-strings.md:273
msgid "\"{s1}-{s2}-{s3}\""
msgstr ""

#: src/ch08-02-strings.md:277
msgid ""
"This code also sets `s` to `tic-tac-toe`. The `format!` macro works like "
"`println!`, but instead of printing the output to the screen, it returns a "
"`String` with the contents. The version of the code using `format!` is much "
"easier to read, and the code generated by the `format!` macro uses "
"references so that this call doesn’t take ownership of any of its parameters."
msgstr ""

#: src/ch08-02-strings.md:283
msgid "Indexing into Strings"
msgstr ""

#: src/ch08-02-strings.md:285
msgid ""
"In many other programming languages, accessing individual characters in a "
"string by referencing them by index is a valid and common operation. "
"However, if you try to access parts of a `String` using indexing syntax in "
"Rust, you’ll get an error. Consider the invalid code in Listing 8-19."
msgstr ""

#: src/ch08-02-strings.md:294
msgid "\"hi\""
msgstr ""

#: src/ch08-02-strings.md:301
msgid "This code will result in the following error:"
msgstr ""

#: src/ch08-02-strings.md:303
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"error[E0277]: the type `str` cannot be indexed by `{integer}`\n"
" --> src/main.rs:3:16\n"
"  |\n"
"3 |     let h = s1[0];\n"
"  |                ^ string indices are ranges of `usize`\n"
"  |\n"
"  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n"
"  = note: you can use `.chars().nth()` or `.bytes().nth()`\n"
"          for more information, see chapter 8 in The Book: <https://doc.rust-"
"lang.org/book/ch08-02-strings.html#indexing-into-strings>\n"
"  = help: the following other types implement trait `SliceIndex<T>`:\n"
"            `usize` implements `SliceIndex<ByteStr>`\n"
"            `usize` implements `SliceIndex<[T]>`\n"
"  = note: required for `String` to implement `Index<{integer}>`\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `collections` (bin \"collections\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:324
msgid ""
"The error tells the story: Rust strings don’t support indexing. But why not? "
"To answer that question, we need to discuss how Rust stores strings in "
"memory."
msgstr ""

#: src/ch08-02-strings.md:327
msgid "Internal Representation"
msgstr ""

#: src/ch08-02-strings.md:329
msgid ""
"A `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly "
"encoded UTF-8 example strings from Listing 8-14. First, this one:"
msgstr ""

#: src/ch08-02-strings.md:348
msgid ""
"In this case, `len` will be `4`, which means the vector storing the string "
"`\"Hola\"` is 4 bytes long. Each of these letters takes 1 byte when encoded "
"in UTF-8. The following line, however, may surprise you (note that this "
"string begins with the capital Cyrillic letter _Ze_, not the number 3):"
msgstr ""

#: src/ch08-02-strings.md:369
msgid ""
"If you were asked how long the string is, you might say 12. In fact, Rust’s "
"answer is 24: That’s the number of bytes it takes to encode “Здравствуйте” "
"in UTF-8, because each Unicode scalar value in that string takes 2 bytes of "
"storage. Therefore, an index into the string’s bytes will not always "
"correlate to a valid Unicode scalar value. To demonstrate, consider this "
"invalid Rust code:"
msgstr ""

#: src/ch08-02-strings.md:381
msgid ""
"You already know that `answer` will not be `З`, the first letter. When "
"encoded in UTF-8, the first byte of `З` is `208` and the second is `151`, so "
"it would seem that `answer` should in fact be `208`, but `208` is not a "
"valid character on its own. Returning `208` is likely not what a user would "
"want if they asked for the first letter of this string; however, that’s the "
"only data that Rust has at byte index 0. Users generally don’t want the byte "
"value returned, even if the string contains only Latin letters: If "
"`&\"hi\"[0]` were valid code that returned the byte value, it would return "
"`104`, not `h`."
msgstr ""

#: src/ch08-02-strings.md:390
msgid ""
"The answer, then, is that to avoid returning an unexpected value and causing "
"bugs that might not be discovered immediately, Rust doesn’t compile this "
"code at all and prevents misunderstandings early in the development process."
msgstr ""

#: src/ch08-02-strings.md:396
msgid "<a id=\"bytes-and-scalar-values-and-grapheme-clusters-oh-my\"></a>"
msgstr ""

#: src/ch08-02-strings.md:398
msgid "Bytes, Scalar Values, and Grapheme Clusters"
msgstr ""

#: src/ch08-02-strings.md:400
msgid ""
"Another point about UTF-8 is that there are actually three relevant ways to "
"look at strings from Rust’s perspective: as bytes, scalar values, and "
"grapheme clusters (the closest thing to what we would call _letters_)."
msgstr ""

#: src/ch08-02-strings.md:404
msgid ""
"If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is "
"stored as a vector of `u8` values that looks like this:"
msgstr ""

#: src/ch08-02-strings.md:412
msgid ""
"That’s 18 bytes and is how computers ultimately store this data. If we look "
"at them as Unicode scalar values, which are what Rust’s `char` type is, "
"those bytes look like this:"
msgstr ""

#: src/ch08-02-strings.md:420
msgid ""
"There are six `char` values here, but the fourth and sixth are not letters: "
"They’re diacritics that don’t make sense on their own. Finally, if we look "
"at them as grapheme clusters, we’d get what a person would call the four "
"letters that make up the Hindi word:"
msgstr ""

#: src/ch08-02-strings.md:425
msgid ""
"```text\n"
"[\"न\", \"म\", \"स्\", \"ते\"]\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:429
msgid ""
"Rust provides different ways of interpreting the raw string data that "
"computers store so that each program can choose the interpretation it needs, "
"no matter what human language the data is in."
msgstr ""

#: src/ch08-02-strings.md:433
msgid ""
"A final reason Rust doesn’t allow us to index into a `String` to get a "
"character is that indexing operations are expected to always take constant "
"time (O(1)). But it isn’t possible to guarantee that performance with a "
"`String`, because Rust would have to walk through the contents from the "
"beginning to the index to determine how many valid characters there were."
msgstr ""

#: src/ch08-02-strings.md:439
msgid "Slicing Strings"
msgstr ""

#: src/ch08-02-strings.md:441
msgid ""
"Indexing into a string is often a bad idea because it’s not clear what the "
"return type of the string-indexing operation should be: a byte value, a "
"character, a grapheme cluster, or a string slice. If you really need to use "
"indices to create string slices, therefore, Rust asks you to be more "
"specific."
msgstr ""

#: src/ch08-02-strings.md:446
msgid ""
"Rather than indexing using `[]` with a single number, you can use `[]` with "
"a range to create a string slice containing particular bytes:"
msgstr ""

#: src/ch08-02-strings.md:455
msgid ""
"Here, `s` will be a `&str` that contains the first 4 bytes of the string. "
"Earlier, we mentioned that each of these characters was 2 bytes, which means "
"`s` will be `Зд`."
msgstr ""

#: src/ch08-02-strings.md:459
msgid ""
"If we were to try to slice only part of a character’s bytes with something "
"like `&hello[0..1]`, Rust would panic at runtime in the same way as if an "
"invalid index were accessed in a vector:"
msgstr ""

#: src/ch08-02-strings.md:463
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling collections v0.1.0 (file:///projects/collections)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n"
"     Running `target/debug/collections`\n"
"\n"
"thread 'main' panicked at src/main.rs:4:19:\n"
"byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of "
"`Здравствуйте`\n"
"note: run with `RUST_BACKTRACE=1` environment variable to display a "
"backtrace\n"
"```"
msgstr ""

#: src/ch08-02-strings.md:474
msgid ""
"You should use caution when creating string slices with ranges, because "
"doing so can crash your program."
msgstr ""

#: src/ch08-02-strings.md:479
msgid "<a id=\"methods-for-iterating-over-strings\"></a>"
msgstr ""

#: src/ch08-02-strings.md:481
msgid "Iterating Over Strings"
msgstr ""

#: src/ch08-02-strings.md:483
msgid ""
"The best way to operate on pieces of strings is to be explicit about whether "
"you want characters or bytes. For individual Unicode scalar values, use the "
"`chars` method. Calling `chars` on “Зд” separates out and returns two values "
"of type `char`, and you can iterate over the result to access each element:"
msgstr ""

#: src/ch08-02-strings.md:489 src/ch08-02-strings.md:505
msgid "\"Зд\""
msgstr ""

#: src/ch08-02-strings.md:490
msgid "\"{c}\""
msgstr ""

#: src/ch08-02-strings.md:494
msgid "This code will print the following:"
msgstr ""

#: src/ch08-02-strings.md:501
msgid ""
"Alternatively, the `bytes` method returns each raw byte, which might be "
"appropriate for your domain:"
msgstr ""

#: src/ch08-02-strings.md:506
msgid "\"{b}\""
msgstr ""

#: src/ch08-02-strings.md:510
msgid "This code will print the 4 bytes that make up this string:"
msgstr ""

#: src/ch08-02-strings.md:519
msgid ""
"But be sure to remember that valid Unicode scalar values may be made up of "
"more than 1 byte."
msgstr ""

#: src/ch08-02-strings.md:522
msgid ""
"Getting grapheme clusters from strings, as with the Devanagari script, is "
"complex, so this functionality is not provided by the standard library. "
"Crates are available on [crates.io](https://crates.io/)<!-- ignore --> if "
"this is the functionality you need."
msgstr ""

#: src/ch08-02-strings.md:529
msgid "<a id=\"strings-are-not-so-simple\"></a>"
msgstr ""

#: src/ch08-02-strings.md:531
msgid "Handling the Complexities of Strings"
msgstr ""

#: src/ch08-02-strings.md:533
msgid ""
"To summarize, strings are complicated. Different programming languages make "
"different choices about how to present this complexity to the programmer. "
"Rust has chosen to make the correct handling of `String` data the default "
"behavior for all Rust programs, which means programmers have to put more "
"thought into handling UTF-8 data up front. This trade-off exposes more of "
"the complexity of strings than is apparent in other programming languages, "
"but it prevents you from having to handle errors involving non-ASCII "
"characters later in your development life cycle."
msgstr ""

#: src/ch08-02-strings.md:542
msgid ""
"The good news is that the standard library offers a lot of functionality "
"built off the `String` and `&str` types to help handle these complex "
"situations correctly. Be sure to check out the documentation for useful "
"methods like `contains` for searching in a string and `replace` for "
"substituting parts of a string with another string."
msgstr ""

#: src/ch08-02-strings.md:548
msgid "Let’s switch to something a bit less complex: hash maps!"
msgstr ""
