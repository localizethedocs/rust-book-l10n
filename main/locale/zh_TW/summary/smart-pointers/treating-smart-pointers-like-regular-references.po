msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch15-02-deref.md:3
msgid ""
"<a id=\"treating-smart-pointers-like-regular-references-with-the-deref-"
"trait\"></a> <a id=\"treating-smart-pointers-like-regular-references-with-"
"deref\"></a>"
msgstr ""

#: src/ch15-02-deref.md:6
msgid "Treating Smart Pointers Like Regular References"
msgstr ""

#: src/ch15-02-deref.md:8
msgid ""
"Implementing the `Deref` trait allows you to customize the behavior of the "
"_dereference operator_ `*` (not to be confused with the multiplication or "
"glob operator). By implementing `Deref` in such a way that a smart pointer "
"can be treated like a regular reference, you can write code that operates on "
"references and use that code with smart pointers too."
msgstr ""

#: src/ch15-02-deref.md:14
msgid ""
"Let’s first look at how the dereference operator works with regular "
"references. Then, we’ll try to define a custom type that behaves like "
"`Box<T>` and see why the dereference operator doesn’t work like a reference "
"on our newly defined type. We’ll explore how implementing the `Deref` trait "
"makes it possible for smart pointers to work in ways similar to references. "
"Then, we’ll look at Rust’s deref coercion feature and how it lets us work "
"with either references or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:24
msgid ""
"<a id=\"following-the-pointer-to-the-value-with-the-dereference-operator\"></"
"a> <a id=\"following-the-pointer-to-the-value\"></a>"
msgstr ""

#: src/ch15-02-deref.md:27
msgid "Following the Reference to the Value"
msgstr ""

#: src/ch15-02-deref.md:29
msgid ""
"A regular reference is a type of pointer, and one way to think of a pointer "
"is as an arrow to a value stored somewhere else. In Listing 15-6, we create "
"a reference to an `i32` value and then use the dereference operator to "
"follow the reference to the value."
msgstr ""

#: src/ch15-02-deref.md:48
msgid ""
"The variable `x` holds an `i32` value `5`. We set `y` equal to a reference "
"to `x`. We can assert that `x` is equal to `5`. However, if we want to make "
"an assertion about the value in `y`, we have to use `*y` to follow the "
"reference to the value it’s pointing to (hence, _dereference_) so that the "
"compiler can compare the actual value. Once we dereference `y`, we have "
"access to the integer value `y` is pointing to that we can compare with `5`."
msgstr ""

#: src/ch15-02-deref.md:55
msgid ""
"If we tried to write `assert_eq!(5, y);` instead, we would get this "
"compilation error:"
msgstr ""

#: src/ch15-02-deref.md:58
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0277]: can't compare `{integer}` with `&{integer}`\n"
" --> src/main.rs:6:5\n"
"  |\n"
"6 |     assert_eq!(5, y);\n"
"  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"
"  |\n"
"  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}"
"`\n"
"  = note: this error originates in the macro `assert_eq` (in Nightly builds, "
"run with -Z macro-backtrace for more info)\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `deref-example` (bin \"deref-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:74
msgid ""
"Comparing a number and a reference to a number isn’t allowed because they’re "
"different types. We must use the dereference operator to follow the "
"reference to the value it’s pointing to."
msgstr ""

#: src/ch15-02-deref.md:78
msgid "Using `Box<T>` Like a Reference"
msgstr ""

#: src/ch15-02-deref.md:80
msgid ""
"We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a "
"reference; the dereference operator used on the `Box<T>` in Listing 15-7 "
"functions in the same way as the dereference operator used on the reference "
"in Listing 15-6."
msgstr ""

#: src/ch15-02-deref.md:99
msgid ""
"The main difference between Listing 15-7 and Listing 15-6 is that here we "
"set `y` to be an instance of a box pointing to a copied value of `x` rather "
"than a reference pointing to the value of `x`. In the last assertion, we can "
"use the dereference operator to follow the box’s pointer in the same way "
"that we did when `y` was a reference. Next, we’ll explore what is special "
"about `Box<T>` that enables us to use the dereference operator by defining "
"our own box type."
msgstr ""

#: src/ch15-02-deref.md:106
msgid "Defining Our Own Smart Pointer"
msgstr ""

#: src/ch15-02-deref.md:108
msgid ""
"Let’s build a wrapper type similar to the `Box<T>` type provided by the "
"standard library to experience how smart pointer types behave differently "
"from references by default. Then, we’ll look at how to add the ability to "
"use the dereference operator."
msgstr ""

#: src/ch15-02-deref.md:113
msgid ""
"Note: There’s one big difference between the `MyBox<T>` type we’re about to "
"build and the real `Box<T>`: Our version will not store its data on the "
"heap. We are focusing this example on `Deref`, so where the data is actually "
"stored is less important than the pointer-like behavior."
msgstr ""

#: src/ch15-02-deref.md:118
msgid ""
"The `Box<T>` type is ultimately defined as a tuple struct with one element, "
"so Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define "
"a `new` function to match the `new` function defined on `Box<T>`."
msgstr ""

#: src/ch15-02-deref.md:138
msgid ""
"We define a struct named `MyBox` and declare a generic parameter `T` because "
"we want our type to hold values of any type. The `MyBox` type is a tuple "
"struct with one element of type `T`. The `MyBox::new` function takes one "
"parameter of type `T` and returns a `MyBox` instance that holds the value "
"passed in."
msgstr ""

#: src/ch15-02-deref.md:143
msgid ""
"Let’s try adding the `main` function in Listing 15-7 to Listing 15-8 and "
"changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. "
"The code in Listing 15-9 won’t compile, because Rust doesn’t know how to "
"dereference `MyBox`."
msgstr ""

#: src/ch15-02-deref.md:170
msgid "Here’s the resultant compilation error:"
msgstr ""

#: src/ch15-02-deref.md:172
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling deref-example v0.1.0 (file:///projects/deref-example)\n"
"error[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n"
"  --> src/main.rs:14:19\n"
"   |\n"
"14 |     assert_eq!(5, *y);\n"
"   |                   ^^ can't be dereferenced\n"
"\n"
"For more information about this error, try `rustc --explain E0614`.\n"
"error: could not compile `deref-example` (bin \"deref-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch15-02-deref.md:185
msgid ""
"Our `MyBox<T>` type can’t be dereferenced because we haven’t implemented "
"that ability on our type. To enable dereferencing with the `*` operator, we "
"implement the `Deref` trait."
msgstr ""

#: src/ch15-02-deref.md:191
msgid ""
"<a id=\"treating-a-type-like-a-reference-by-implementing-the-deref-trait\"></"
"a>"
msgstr ""

#: src/ch15-02-deref.md:193
msgid "Implementing the `Deref` Trait"
msgstr ""

#: src/ch15-02-deref.md:195
msgid ""
"As discussed in [“Implementing a Trait on a Type”](ch10-02-traits."
"html#implementing-a-trait-on-a-type)<!-- ignore --> in Chapter 10, to "
"implement a trait we need to provide implementations for the trait’s "
"required methods. The `Deref` trait, provided by the standard library, "
"requires us to implement one method named `deref` that borrows `self` and "
"returns a reference to the inner data. Listing 15-10 contains an "
"implementation of `Deref` to add to the definition of `MyBox<T>`."
msgstr ""

#: src/ch15-02-deref.md:234
msgid ""
"The `type Target = T;` syntax defines an associated type for the `Deref` "
"trait to use. Associated types are a slightly different way of declaring a "
"generic parameter, but you don’t need to worry about them for now; we’ll "
"cover them in more detail in Chapter 20."
msgstr ""

#: src/ch15-02-deref.md:239
msgid ""
"We fill in the body of the `deref` method with `&self.0` so that `deref` "
"returns a reference to the value we want to access with the `*` operator; "
"recall from [“Creating Different Types with Tuple Structs”](ch05-01-defining-"
"structs.html#creating-different-types-with-tuple-structs)<!--\n"
"ignore --> in Chapter 5 that `.0` accesses the first value in a tuple "
"struct. The `main` function in Listing 15-9 that calls `*` on the `MyBox<T>` "
"value now compiles, and the assertions pass!"
msgstr ""

#: src/ch15-02-deref.md:246
msgid ""
"Without the `Deref` trait, the compiler can only dereference `&` references. "
"The `deref` method gives the compiler the ability to take a value of any "
"type that implements `Deref` and call the `deref` method to get a reference "
"that it knows how to dereference."
msgstr ""

#: src/ch15-02-deref.md:251
msgid ""
"When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran "
"this code:"
msgstr ""

#: src/ch15-02-deref.md:258
msgid ""
"Rust substitutes the `*` operator with a call to the `deref` method and then "
"a plain dereference so that we don’t have to think about whether or not we "
"need to call the `deref` method. This Rust feature lets us write code that "
"functions identically whether we have a regular reference or a type that "
"implements `Deref`."
msgstr ""

#: src/ch15-02-deref.md:264
msgid ""
"The reason the `deref` method returns a reference to a value, and that the "
"plain dereference outside the parentheses in `*(y.deref())` is still "
"necessary, has to do with the ownership system. If the `deref` method "
"returned the value directly instead of a reference to the value, the value "
"would be moved out of `self`. We don’t want to take ownership of the inner "
"value inside `MyBox<T>` in this case or in most cases where we use the "
"dereference operator."
msgstr ""

#: src/ch15-02-deref.md:271
msgid ""
"Note that the `*` operator is replaced with a call to the `deref` method and "
"then a call to the `*` operator just once, each time we use a `*` in our "
"code. Because the substitution of the `*` operator does not recurse "
"infinitely, we end up with data of type `i32`, which matches the `5` in "
"`assert_eq!` in Listing 15-9."
msgstr ""

#: src/ch15-02-deref.md:279
msgid ""
"<a id=\"implicit-deref-coercions-with-functions-and-methods\"></a> <a "
"id=\"using-deref-coercions-in-functions-and-methods\"></a>"
msgstr ""

#: src/ch15-02-deref.md:282
msgid "Using Deref Coercion in Functions and Methods"
msgstr ""

#: src/ch15-02-deref.md:284
msgid ""
"_Deref coercion_ converts a reference to a type that implements the `Deref` "
"trait into a reference to another type. For example, deref coercion can "
"convert `&String` to `&str` because `String` implements the `Deref` trait "
"such that it returns `&str`. Deref coercion is a convenience Rust performs "
"on arguments to functions and methods, and it works only on types that "
"implement the `Deref` trait. It happens automatically when we pass a "
"reference to a particular type’s value as an argument to a function or "
"method that doesn’t match the parameter type in the function or method "
"definition. A sequence of calls to the `deref` method converts the type we "
"provided into the type the parameter needs."
msgstr ""

#: src/ch15-02-deref.md:294
msgid ""
"Deref coercion was added to Rust so that programmers writing function and "
"method calls don’t need to add as many explicit references and dereferences "
"with `&` and `*`. The deref coercion feature also lets us write more code "
"that can work for either references or smart pointers."
msgstr ""

#: src/ch15-02-deref.md:299
msgid ""
"To see deref coercion in action, let’s use the `MyBox<T>` type we defined in "
"Listing 15-8 as well as the implementation of `Deref` that we added in "
"Listing 15-10. Listing 15-11 shows the definition of a function that has a "
"string slice parameter."
msgstr ""

#: src/ch15-02-deref.md:308 src/ch15-02-deref.md:342 src/ch15-02-deref.md:387
msgid "\"Hello, {name}!\""
msgstr ""

#: src/ch15-02-deref.md:316
msgid ""
"We can call the `hello` function with a string slice as an argument, such as "
"`hello(\"Rust\");`, for example. Deref coercion makes it possible to call "
"`hello` with a reference to a value of type `MyBox<String>`, as shown in "
"Listing 15-12."
msgstr ""

#: src/ch15-02-deref.md:346 src/ch15-02-deref.md:391
msgid "\"Rust\""
msgstr ""

#: src/ch15-02-deref.md:353
msgid ""
"Here we’re calling the `hello` function with the argument `&m`, which is a "
"reference to a `MyBox<String>` value. Because we implemented the `Deref` "
"trait on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into "
"`&String` by calling `deref`. The standard library provides an "
"implementation of `Deref` on `String` that returns a string slice, and this "
"is in the API documentation for `Deref`. Rust calls `deref` again to turn "
"the `&String` into `&str`, which matches the `hello` function’s definition."
msgstr ""

#: src/ch15-02-deref.md:361
msgid ""
"If Rust didn’t implement deref coercion, we would have to write the code in "
"Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a "
"value of type `&MyBox<String>`."
msgstr ""

#: src/ch15-02-deref.md:398
msgid ""
"The `(*m)` dereferences the `MyBox<String>` into a `String`. Then, the `&` "
"and `[..]` take a string slice of the `String` that is equal to the whole "
"string to match the signature of `hello`. This code without deref coercions "
"is harder to read, write, and understand with all of these symbols involved. "
"Deref coercion allows Rust to handle these conversions for us automatically."
msgstr ""

#: src/ch15-02-deref.md:404
msgid ""
"When the `Deref` trait is defined for the types involved, Rust will analyze "
"the types and use `Deref::deref` as many times as necessary to get a "
"reference to match the parameter’s type. The number of times that `Deref::"
"deref` needs to be inserted is resolved at compile time, so there is no "
"runtime penalty for taking advantage of deref coercion!"
msgstr ""

#: src/ch15-02-deref.md:412
msgid "<a id=\"how-deref-coercion-interacts-with-mutability\"></a>"
msgstr ""

#: src/ch15-02-deref.md:414
msgid "Handling Deref Coercion with Mutable References"
msgstr ""

#: src/ch15-02-deref.md:416
msgid ""
"Similar to how you use the `Deref` trait to override the `*` operator on "
"immutable references, you can use the `DerefMut` trait to override the `*` "
"operator on mutable references."
msgstr ""

#: src/ch15-02-deref.md:420
msgid ""
"Rust does deref coercion when it finds types and trait implementations in "
"three cases:"
msgstr ""

#: src/ch15-02-deref.md:423
msgid "From `&T` to `&U` when `T: Deref<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:424
msgid "From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:425
msgid "From `&mut T` to `&U` when `T: Deref<Target=U>`"
msgstr ""

#: src/ch15-02-deref.md:427
msgid ""
"The first two cases are the same except that the second implements "
"mutability. The first case states that if you have a `&T`, and `T` "
"implements `Deref` to some type `U`, you can get a `&U` transparently. The "
"second case states that the same deref coercion happens for mutable "
"references."
msgstr ""

#: src/ch15-02-deref.md:432
msgid ""
"The third case is trickier: Rust will also coerce a mutable reference to an "
"immutable one. But the reverse is _not_ possible: Immutable references will "
"never coerce to mutable references. Because of the borrowing rules, if you "
"have a mutable reference, that mutable reference must be the only reference "
"to that data (otherwise, the program wouldn’t compile). Converting one "
"mutable reference to one immutable reference will never break the borrowing "
"rules. Converting an immutable reference to a mutable reference would "
"require that the initial immutable reference is the only immutable reference "
"to that data, but the borrowing rules don’t guarantee that. Therefore, Rust "
"can’t make the assumption that converting an immutable reference to a "
"mutable reference is possible."
msgstr ""
