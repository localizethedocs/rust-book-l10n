msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch20-04-advanced-functions-and-closures.md:1
msgid "Advanced Functions and Closures"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:3
msgid ""
"This section explores some advanced features related to functions and "
"closures, including function pointers and returning closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:6
msgid "Function Pointers"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:8
msgid ""
"We’ve talked about how to pass closures to functions; you can also pass "
"regular functions to functions! This technique is useful when you want to "
"pass a function you’ve already defined rather than defining a new closure. "
"Functions coerce to the type `fn` (with a lowercase _f_), not to be confused "
"with the `Fn` closure trait. The `fn` type is called a _function pointer_. "
"Passing functions with function pointers will allow you to use functions as "
"arguments to other functions."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:16
msgid ""
"The syntax for specifying that a parameter is a function pointer is similar "
"to that of closures, as shown in Listing 20-28, where we’ve defined a "
"function `add_one` that adds 1 to its parameter. The function `do_twice` "
"takes two parameters: a function pointer to any function that takes an `i32` "
"parameter and returns an `i32`, and one `i32` value. The `do_twice` function "
"calls the function `f` twice, passing it the `arg` value, then adds the two "
"function call results together. The `main` function calls `do_twice` with "
"the arguments `add_one` and `5`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:39
msgid "\"The answer is: {answer}\""
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:45
msgid ""
"This code prints `The answer is: 12`. We specify that the parameter `f` in "
"`do_twice` is an `fn` that takes one parameter of type `i32` and returns an "
"`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can "
"pass the function name `add_one` as the first argument to `do_twice`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:50
msgid ""
"Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as "
"the parameter type directly rather than declaring a generic type parameter "
"with one of the `Fn` traits as a trait bound."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:54
msgid ""
"Function pointers implement all three of the closure traits (`Fn`, `FnMut`, "
"and `FnOnce`), meaning you can always pass a function pointer as an argument "
"for a function that expects a closure. It’s best to write functions using a "
"generic type and one of the closure traits so that your functions can accept "
"either functions or closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:60
msgid ""
"That said, one example of where you would want to only accept `fn` and not "
"closures is when interfacing with external code that doesn’t have closures: "
"C functions can accept functions as arguments, but C doesn’t have closures."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:64
msgid ""
"As an example of where you could use either a closure defined inline or a "
"named function, let’s look at a use of the `map` method provided by the "
"`Iterator` trait in the standard library. To use the `map` method to turn a "
"vector of numbers into a vector of strings, we could use a closure, as in "
"Listing 20-29."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:81
msgid ""
"Or we could name a function as the argument to `map` instead of the closure. "
"Listing 20-30 shows what this would look like."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:96
msgid ""
"Note that we must use the fully qualified syntax that we talked about in the "
"[“Advanced Traits”](ch20-02-advanced-traits.html#advanced-traits)<!-- ignore "
"--> section because there are multiple functions available named `to_string`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:100
msgid ""
"Here, we’re using the `to_string` function defined in the `ToString` trait, "
"which the standard library has implemented for any type that implements "
"`Display`."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:104
msgid ""
"Recall from the [“Enum Values”](ch06-01-defining-an-enum.html#enum-"
"values)<!-- ignore --> section in Chapter 6 that the name of each enum "
"variant that we define also becomes an initializer function. We can use "
"these initializer functions as function pointers that implement the closure "
"traits, which means we can specify the initializer functions as arguments "
"for methods that take closures, as seen in Listing 20-31."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:125
msgid ""
"Here, we create `Status::Value` instances using each `u32` value in the "
"range that `map` is called on by using the initializer function of `Status::"
"Value`. Some people prefer this style and some people prefer to use "
"closures. They compile to the same code, so use whichever style is clearer "
"to you."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:130
msgid "Returning Closures"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:132
msgid ""
"Closures are represented by traits, which means you can’t return closures "
"directly. In most cases where you might want to return a trait, you can "
"instead use the concrete type that implements the trait as the return value "
"of the function. However, you can’t usually do that with closures because "
"they don’t have a concrete type that is returnable; you’re not allowed to "
"use the function pointer `fn` as a return type if the closure captures any "
"values from its scope, for example."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:140
msgid ""
"Instead, you will normally use the `impl Trait` syntax we learned about in "
"Chapter 10. You can return any function type, using `Fn`, `FnOnce`, and "
"`FnMut`. For example, the code in Listing 20-32 will compile just fine."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:154
msgid ""
"However, as we noted in the [“Inferring and Annotating Closure Types”]"
"(ch13-01-closures.html#closure-type-inference-and-annotation)<!-- ignore --> "
"section in Chapter 13, each closure is also its own distinct type. If you "
"need to work with multiple functions that have the same signature but "
"different implementations, you will need to use a trait object for them. "
"Consider what happens if you write code like that shown in Listing 20-33."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:168
#: src/ch20-04-advanced-functions-and-closures.md:229
msgid "\"{output}\""
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:183
msgid ""
"Here we have two functions, `returns_closure` and "
"`returns_initialized_closure`, which both return `impl Fn(i32) -> i32`. "
"Notice that the closures that they return are different, even though they "
"implement the same type. If we try to compile this, Rust lets us know that "
"it won’t work:"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:188
msgid ""
"```text\n"
"$ cargo build\n"
"   Compiling functions-example v0.1.0 (file:///projects/functions-example)\n"
"error[E0308]: mismatched types\n"
"  --> src/main.rs:2:44\n"
"   |\n"
" 2 |     let handlers = vec![returns_closure(), "
"returns_initialized_closure(123)];\n"
"   |                                            "
"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different "
"opaque type\n"
"...\n"
" 9 | fn returns_closure() -> impl Fn(i32) -> i32 {\n"
"   |                         ------------------- the expected opaque type\n"
"...\n"
"13 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {\n"
"   |                                              ------------------- the "
"found opaque type\n"
"   |\n"
"   = note: expected opaque type `impl Fn(i32) -> i32`\n"
"              found opaque type `impl Fn(i32) -> i32`\n"
"   = note: distinct uses of `impl Trait` result in different opaque types\n"
"\n"
"For more information about this error, try `rustc --explain E0308`.\n"
"error: could not compile `functions-example` (bin \"functions-example\") due "
"to 1 previous error\n"
"```"
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:211
msgid ""
"The error message tells us that whenever we return an `impl Trait`, Rust "
"creates a unique _opaque type_, a type where we cannot see into the details "
"of what Rust constructs for us, nor can we guess the type Rust will generate "
"to write ourselves. So, even though these functions return closures that "
"implement the same trait, `Fn(i32) -> i32`, the opaque types Rust generates "
"for each are distinct. (This is similar to how Rust produces different "
"concrete types for distinct async blocks even when they have the same output "
"type, as we saw in [“The `Pin` Type and the `Unpin` Trait”](ch17-03-more-"
"futures.html)<!-- ignore --> in Chapter 17.) We have seen a solution to this "
"problem a few times now: We can use a trait object, as in Listing 20-34."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:244
msgid ""
"This code will compile just fine. For more about trait objects, refer to the "
"section [“Using Trait Objects To Abstract over Shared Behavior”](ch18-02-"
"trait-objects.html)<!-- ignore --> in Chapter 18."
msgstr ""

#: src/ch20-04-advanced-functions-and-closures.md:248
msgid "Next, let’s look at macros!"
msgstr ""
