msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch18-03-oo-design-patterns.md:1
msgid "Implementing an Object-Oriented Design Pattern"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:3
msgid ""
"The _state pattern_ is an object-oriented design pattern. The crux of the "
"pattern is that we define a set of states a value can have internally. The "
"states are represented by a set of _state objects_, and the value’s behavior "
"changes based on its state. We’re going to work through an example of a blog "
"post struct that has a field to hold its state, which will be a state object "
"from the set “draft,” “review,” or “published.”"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:10
msgid ""
"The state objects share functionality: In Rust, of course, we use structs "
"and traits rather than objects and inheritance. Each state object is "
"responsible for its own behavior and for governing when it should change "
"into another state. The value that holds a state object knows nothing about "
"the different behavior of the states or when to transition between states."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:16
msgid ""
"The advantage of using the state pattern is that, when the business "
"requirements of the program change, we won’t need to change the code of the "
"value holding the state or the code that uses the value. We’ll only need to "
"update the code inside one of the state objects to change its rules or "
"perhaps add more state objects."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:22
msgid ""
"First, we’re going to implement the state pattern in a more traditional "
"object-oriented way. Then, we’ll use an approach that’s a bit more natural "
"in Rust. Let’s dig in to incrementally implement a blog post workflow using "
"the state pattern."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:27
msgid "The final functionality will look like this:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:29
msgid "A blog post starts as an empty draft."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:30
msgid "When the draft is done, a review of the post is requested."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:31
msgid "When the post is approved, it gets published."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:32
msgid ""
"Only published blog posts return content to print so that unapproved posts "
"can’t accidentally be published."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:35
msgid ""
"Any other changes attempted on a post should have no effect. For example, if "
"we try to approve a draft blog post before we’ve requested a review, the "
"post should remain an unpublished draft."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:41
msgid "<a id=\"a-traditional-object-oriented-attempt\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:43
msgid "Attempting Traditional Object-Oriented Style"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:45
msgid ""
"There are infinite ways to structure code to solve the same problem, each "
"with different trade-offs. This section’s implementation is more of a "
"traditional object-oriented style, which is possible to write in Rust, but "
"doesn’t take advantage of some of Rust’s strengths. Later, we’ll demonstrate "
"a different solution that still uses the object-oriented design pattern but "
"is structured in a way that might look less familiar to programmers with "
"object-oriented experience. We’ll compare the two solutions to experience "
"the trade-offs of designing Rust code differently than code in other "
"languages."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:54
msgid ""
"Listing 18-11 shows this workflow in code form: This is an example usage of "
"the API we’ll implement in a library crate named `blog`. This won’t compile "
"yet because we haven’t implemented the `blog` crate."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:66 src/ch18-03-oo-design-patterns.md:73
#: src/ch18-03-oo-design-patterns.md:788 src/ch18-03-oo-design-patterns.md:795
#: src/ch18-03-oo-design-patterns.md:951 src/ch18-03-oo-design-patterns.md:957
msgid "\"I ate a salad for lunch today\""
msgstr ""

#: src/ch18-03-oo-design-patterns.md:67 src/ch18-03-oo-design-patterns.md:70
#: src/ch18-03-oo-design-patterns.md:244 src/ch18-03-oo-design-patterns.md:292
#: src/ch18-03-oo-design-patterns.md:400 src/ch18-03-oo-design-patterns.md:630
#: src/ch18-03-oo-design-patterns.md:789 src/ch18-03-oo-design-patterns.md:792
msgid "\"\""
msgstr ""

#: src/ch18-03-oo-design-patterns.md:79
msgid ""
"We want to allow the user to create a new draft blog post with `Post::new`. "
"We want to allow text to be added to the blog post. If we try to get the "
"post’s content immediately, before approval, we shouldn’t get any text "
"because the post is still a draft. We’ve added `assert_eq!` in the code for "
"demonstration purposes. An excellent unit test for this would be to assert "
"that a draft blog post returns an empty string from the `content` method, "
"but we’re not going to write tests for this example."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:87
msgid ""
"Next, we want to enable a request for a review of the post, and we want "
"`content` to return an empty string while waiting for the review. When the "
"post receives approval, it should get published, meaning the text of the "
"post will be returned when `content` is called."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:92
msgid ""
"Notice that the only type we’re interacting with from the crate is the "
"`Post` type. This type will use the state pattern and will hold a value that "
"will be one of three state objects representing the various states a post "
"can be in—draft, review, or published. Changing from one state to another "
"will be managed internally within the `Post` type. The states change in "
"response to the methods called by our library’s users on the `Post` "
"instance, but they don’t have to manage the state changes directly. Also, "
"users can’t make a mistake with the states, such as publishing a post before "
"it’s reviewed."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:103
msgid ""
"<a id=\"defining-post-and-creating-a-new-instance-in-the-draft-state\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:105
msgid "Defining `Post` and Creating a New Instance"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:107
msgid ""
"Let’s get started on the implementation of the library! We know we need a "
"public `Post` struct that holds some content, so we’ll start with the "
"definition of the struct and an associated public `new` function to create "
"an instance of `Post`, as shown in Listing 18-12. We’ll also make a private "
"`State` trait that will define the behavior that all state objects for a "
"`Post` must have."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:114
msgid ""
"Then, `Post` will hold a trait object of `Box<dyn State>` inside an "
"`Option<T>` in a private field named `state` to hold the state object. "
"You’ll see why the `Option<T>` is necessary in a bit."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:144
msgid ""
"The `State` trait defines the behavior shared by different post states. The "
"state objects are `Draft`, `PendingReview`, and `Published`, and they will "
"all implement the `State` trait. For now, the trait doesn’t have any "
"methods, and we’ll start by defining just the `Draft` state because that is "
"the state we want a post to start in."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:150
msgid ""
"When we create a new `Post`, we set its `state` field to a `Some` value that "
"holds a `Box`. This `Box` points to a new instance of the `Draft` struct. "
"This ensures that whenever we create a new instance of `Post`, it will start "
"out as a draft. Because the `state` field of `Post` is private, there is no "
"way to create a `Post` in any other state! In the `Post::new` function, we "
"set the `content` field to a new, empty `String`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:157
msgid "Storing the Text of the Post Content"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:159
msgid ""
"We saw in Listing 18-11 that we want to be able to call a method named "
"`add_text` and pass it a `&str` that is then added as the text content of "
"the blog post. We implement this as a method, rather than exposing the "
"`content` field as `pub`, so that later we can implement a method that will "
"control how the `content` field’s data is read. The `add_text` method is "
"pretty straightforward, so let’s add the implementation in Listing 18-13 to "
"the `impl Post` block."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:176 src/ch18-03-oo-design-patterns.md:231
#: src/ch18-03-oo-design-patterns.md:279 src/ch18-03-oo-design-patterns.md:387
#: src/ch18-03-oo-design-patterns.md:424 src/ch18-03-oo-design-patterns.md:437
#: src/ch18-03-oo-design-patterns.md:487 src/ch18-03-oo-design-patterns.md:502
#: src/ch18-03-oo-design-patterns.md:625 src/ch18-03-oo-design-patterns.md:633
#: src/ch18-03-oo-design-patterns.md:663 src/ch18-03-oo-design-patterns.md:896
msgid "// --snip--\n"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:198
msgid ""
"The `add_text` method takes a mutable reference to `self` because we’re "
"changing the `Post` instance that we’re calling `add_text` on. We then call "
"`push_str` on the `String` in `content` and pass the `text` argument to add "
"to the saved `content`. This behavior doesn’t depend on the state the post "
"is in, so it’s not part of the state pattern. The `add_text` method doesn’t "
"interact with the `state` field at all, but it is part of the behavior we "
"want to support."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:208
msgid "<a id=\"ensuring-the-content-of-a-draft-post-is-empty\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:210
msgid "Ensuring That the Content of a Draft Post Is Empty"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:212
msgid ""
"Even after we’ve called `add_text` and added some content to our post, we "
"still want the `content` method to return an empty string slice because the "
"post is still in the draft state, as shown by the first `assert_eq!` in "
"Listing 18-11. For now, let’s implement the `content` method with the "
"simplest thing that will fulfill this requirement: always returning an empty "
"string slice. We’ll change this later once we implement the ability to "
"change a post’s state so that it can be published. So far, posts can only be "
"in the draft state, so the post content should always be empty. Listing "
"18-14 shows this placeholder implementation."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:257
msgid ""
"With this added `content` method, everything in Listing 18-11 through the "
"first `assert_eq!` works as intended."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:262
msgid ""
"<a id=\"requesting-a-review-of-the-post-changes-its-state\"></a> <a "
"id=\"requesting-a-review-changes-the-posts-state\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:265
msgid "Requesting a Review, Which Changes the Post’s State"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:267
msgid ""
"Next, we need to add functionality to request a review of a post, which "
"should change its state from `Draft` to `PendingReview`. Listing 18-15 shows "
"this code."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:325
msgid ""
"We give `Post` a public method named `request_review` that will take a "
"mutable reference to `self`. Then, we call an internal `request_review` "
"method on the current state of `Post`, and this second `request_review` "
"method consumes the current state and returns a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:330
msgid ""
"We add the `request_review` method to the `State` trait; all types that "
"implement the trait will now need to implement the `request_review` method. "
"Note that rather than having `self`, `&self`, or `&mut self` as the first "
"parameter of the method, we have `self: Box<Self>`. This syntax means the "
"method is only valid when called on a `Box` holding the type. This syntax "
"takes ownership of `Box<Self>`, invalidating the old state so that the state "
"value of the `Post` can transform into a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:338
msgid ""
"To consume the old state, the `request_review` method needs to take "
"ownership of the state value. This is where the `Option` in the `state` "
"field of `Post` comes in: We call the `take` method to take the `Some` value "
"out of the `state` field and leave a `None` in its place because Rust "
"doesn’t let us have unpopulated fields in structs. This lets us move the "
"`state` value out of `Post` rather than borrowing it. Then, we’ll set the "
"post’s `state` value to the result of this operation."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:346
msgid ""
"We need to set `state` to `None` temporarily rather than setting it directly "
"with code like `self.state = self.state.request_review();` to get ownership "
"of the `state` value. This ensures that `Post` can’t use the old `state` "
"value after we’ve transformed it into a new state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:351
msgid ""
"The `request_review` method on `Draft` returns a new, boxed instance of a "
"new `PendingReview` struct, which represents the state when a post is "
"waiting for a review. The `PendingReview` struct also implements the "
"`request_review` method but doesn’t do any transformations. Rather, it "
"returns itself because when we request a review on a post already in the "
"`PendingReview` state, it should stay in the `PendingReview` state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:358
msgid ""
"Now we can start seeing the advantages of the state pattern: The "
"`request_review` method on `Post` is the same no matter its `state` value. "
"Each state is responsible for its own rules."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:362
msgid ""
"We’ll leave the `content` method on `Post` as is, returning an empty string "
"slice. We can now have a `Post` in the `PendingReview` state as well as in "
"the `Draft` state, but we want the same behavior in the `PendingReview` "
"state. Listing 18-11 now works up to the second `assert_eq!` call!"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:369
msgid ""
"<a id=\"adding-the-approve-method-that-changes-the-behavior-of-content\"></"
"a> <a id=\"adding-approve-to-change-the-behavior-of-content\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:372
msgid "Adding `approve` to Change `content`'s Behavior"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:374
msgid ""
"The `approve` method will be similar to the `request_review` method: It will "
"set `state` to the value that the current state says it should have when "
"that state is approved, as shown in Listing 18-16."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:462
msgid ""
"We add the `approve` method to the `State` trait and add a new struct that "
"implements `State`, the `Published` state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:465
msgid ""
"Similar to the way `request_review` on `PendingReview` works, if we call the "
"`approve` method on a `Draft`, it will have no effect because `approve` will "
"return `self`. When we call `approve` on `PendingReview`, it returns a new, "
"boxed instance of the `Published` struct. The `Published` struct implements "
"the `State` trait, and for both the `request_review` method and the "
"`approve` method, it returns itself because the post should stay in the "
"`Published` state in those cases."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:473
msgid ""
"Now we need to update the `content` method on `Post`. We want the value "
"returned from `content` to depend on the current state of the `Post`, so "
"we’re going to have the `Post` delegate to a `content` method defined on its "
"`state`, as shown in Listing 18-17."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:561
msgid ""
"Because the goal is to keep all of these rules inside the structs that "
"implement `State`, we call a `content` method on the value in `state` and "
"pass the post instance (that is, `self`) as an argument. Then, we return the "
"value that’s returned from using the `content` method on the `state` value."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:566
msgid ""
"We call the `as_ref` method on the `Option` because we want a reference to "
"the value inside the `Option` rather than ownership of the value. Because "
"`state` is an `Option<Box<dyn State>>`, when we call `as_ref`, an "
"`Option<&Box<dyn State>>` is returned. If we didn’t call `as_ref`, we would "
"get an error because we can’t move `state` out of the borrowed `&self` of "
"the function parameter."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:572
msgid ""
"We then call the `unwrap` method, which we know will never panic because we "
"know the methods on `Post` ensure that `state` will always contain a `Some` "
"value when those methods are done. This is one of the cases we talked about "
"in the [“When You Have More Information Than the Compiler”](ch09-03-to-panic-"
"or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-"
"compiler)<!-- ignore --> section of Chapter 9 when we know that a `None` "
"value is never possible, even though the compiler isn’t able to understand "
"that."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:580
msgid ""
"At this point, when we call `content` on the `&Box<dyn State>`, deref "
"coercion will take effect on the `&` and the `Box` so that the `content` "
"method will ultimately be called on the type that implements the `State` "
"trait. That means we need to add `content` to the `State` trait definition, "
"and that is where we’ll put the logic for what content to return depending "
"on which state we have, as shown in Listing 18-18."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:680
msgid ""
"We add a default implementation for the `content` method that returns an "
"empty string slice. That means we don’t need to implement `content` on the "
"`Draft` and `PendingReview` structs. The `Published` struct will override "
"the `content` method and return the value in `post.content`. While "
"convenient, having the `content` method on `State` determine the content of "
"the `Post` is blurring the lines between the responsibility of `State` and "
"the responsibility of `Post`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:688
msgid ""
"Note that we need lifetime annotations on this method, as we discussed in "
"Chapter 10. We’re taking a reference to a `post` as an argument and "
"returning a reference to part of that `post`, so the lifetime of the "
"returned reference is related to the lifetime of the `post` argument."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:693
msgid ""
"And we’re done—all of Listing 18-11 now works! We’ve implemented the state "
"pattern with the rules of the blog post workflow. The logic related to the "
"rules lives in the state objects rather than being scattered throughout "
"`Post`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:697
msgid "Why Not An Enum?"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:699
msgid ""
"You may have been wondering why we didn’t use an enum with the different "
"possible post states as variants. That’s certainly a possible solution; try "
"it and compare the end results to see which you prefer! One disadvantage of "
"using an enum is that every place that checks the value of the enum will "
"need a `match` expression or similar to handle every possible variant. This "
"could get more repetitive than this trait object solution."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:708
msgid "<a id=\"trade-offs-of-the-state-pattern\"></a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:710
msgid "Evaluating the State Pattern"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:712
msgid ""
"We’ve shown that Rust is capable of implementing the object-oriented state "
"pattern to encapsulate the different kinds of behavior a post should have in "
"each state. The methods on `Post` know nothing about the various behaviors. "
"Because of the way we organized the code, we have to look in only one place "
"to know the different ways a published post can behave: the implementation "
"of the `State` trait on the `Published` struct."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:719
msgid ""
"If we were to create an alternative implementation that didn’t use the state "
"pattern, we might instead use `match` expressions in the methods on `Post` "
"or even in the `main` code that checks the state of the post and changes "
"behavior in those places. That would mean we would have to look in several "
"places to understand all the implications of a post being in the published "
"state."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:725
msgid ""
"With the state pattern, the `Post` methods and the places we use `Post` "
"don’t need `match` expressions, and to add a new state, we would only need "
"to add a new struct and implement the trait methods on that one struct in "
"one location."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:729
msgid ""
"The implementation using the state pattern is easy to extend to add more "
"functionality. To see the simplicity of maintaining code that uses the state "
"pattern, try a few of these suggestions:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:733
msgid ""
"Add a `reject` method that changes the post’s state from `PendingReview` "
"back to `Draft`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:735
msgid ""
"Require two calls to `approve` before the state can be changed to "
"`Published`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:736
msgid ""
"Allow users to add text content only when a post is in the `Draft` state. "
"Hint: have the state object responsible for what might change about the "
"content but not responsible for modifying the `Post`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:740
msgid ""
"One downside of the state pattern is that, because the states implement the "
"transitions between states, some of the states are coupled to each other. If "
"we add another state between `PendingReview` and `Published`, such as "
"`Scheduled`, we would have to change the code in `PendingReview` to "
"transition to `Scheduled` instead. It would be less work if `PendingReview` "
"didn’t need to change with the addition of a new state, but that would mean "
"switching to another design pattern."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:748
msgid ""
"Another downside is that we’ve duplicated some logic. To eliminate some of "
"the duplication, we might try to make default implementations for the "
"`request_review` and `approve` methods on the `State` trait that return "
"`self`. However, this wouldn’t work: When using `State` as a trait object, "
"the trait doesn’t know what the concrete `self` will be exactly, so the "
"return type isn’t known at compile time. (This is one of the dyn "
"compatibility rules mentioned earlier.)"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:756
msgid ""
"Other duplication includes the similar implementations of the "
"`request_review` and `approve` methods on `Post`. Both methods use `Option::"
"take` with the `state` field of `Post`, and if `state` is `Some`, they "
"delegate to the wrapped value’s implementation of the same method and set "
"the new value of the `state` field to the result. If we had a lot of methods "
"on `Post` that followed this pattern, we might consider defining a macro to "
"eliminate the repetition (see the [“Macros”](ch20-05-macros.html#macros)<!-- "
"ignore --> section in Chapter 20)."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:764
msgid ""
"By implementing the state pattern exactly as it’s defined for object-"
"oriented languages, we’re not taking as full advantage of Rust’s strengths "
"as we could. Let’s look at some changes we can make to the `blog` crate that "
"can make invalid states and transitions into compile-time errors."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:769
msgid "Encoding States and Behavior as Types"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:771
msgid ""
"We’ll show you how to rethink the state pattern to get a different set of "
"trade-offs. Rather than encapsulating the states and transitions completely "
"so that outside code has no knowledge of them, we’ll encode the states into "
"different types. Consequently, Rust’s type-checking system will prevent "
"attempts to use draft posts where only published posts are allowed by "
"issuing a compiler error."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:778
msgid "Let’s consider the first part of `main` in Listing 18-11:"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:801
msgid ""
"We still enable the creation of new posts in the draft state using `Post::"
"new` and the ability to add text to the post’s content. But instead of "
"having a `content` method on a draft post that returns an empty string, "
"we’ll make it so that draft posts don’t have the `content` method at all. "
"That way, if we try to get a draft post’s content, we’ll get a compiler "
"error telling us the method doesn’t exist. As a result, it will be "
"impossible for us to accidentally display draft post content in production "
"because that code won’t even compile. Listing 18-19 shows the definition of "
"a `Post` struct and a `DraftPost` struct, as well as methods on each."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:843
msgid ""
"Both the `Post` and `DraftPost` structs have a private `content` field that "
"stores the blog post text. The structs no longer have the `state` field "
"because we’re moving the encoding of the state to the types of the structs. "
"The `Post` struct will represent a published post, and it has a `content` "
"method that returns the `content`."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:849
msgid ""
"We still have a `Post::new` function, but instead of returning an instance "
"of `Post`, it returns an instance of `DraftPost`. Because `content` is "
"private and there aren’t any functions that return `Post`, it’s not possible "
"to create an instance of `Post` right now."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:854
msgid ""
"The `DraftPost` struct has an `add_text` method, so we can add text to "
"`content` as before, but note that `DraftPost` does not have a `content` "
"method defined! So now the program ensures that all posts start as draft "
"posts, and draft posts don’t have their content available for display. Any "
"attempt to get around these constraints will result in a compiler error."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:862
msgid ""
"<a id=\"implementing-transitions-as-transformations-into-different-types\"></"
"a>"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:864
msgid ""
"So, how do we get a published post? We want to enforce the rule that a draft "
"post has to be reviewed and approved before it can be published. A post in "
"the pending review state should still not display any content. Let’s "
"implement these constraints by adding another struct, `PendingReviewPost`, "
"defining the `request_review` method on `DraftPost` to return a "
"`PendingReviewPost` and defining an `approve` method on `PendingReviewPost` "
"to return a `Post`, as shown in Listing 18-20."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:923
msgid ""
"The `request_review` and `approve` methods take ownership of `self`, thus "
"consuming the `DraftPost` and `PendingReviewPost` instances and transforming "
"them into a `PendingReviewPost` and a published `Post`, respectively. This "
"way, we won’t have any lingering `DraftPost` instances after we’ve called "
"`request_review` on them, and so forth. The `PendingReviewPost` struct "
"doesn’t have a `content` method defined on it, so attempting to read its "
"content results in a compiler error, as with `DraftPost`. Because the only "
"way to get a published `Post` instance that does have a `content` method "
"defined is to call the `approve` method on a `PendingReviewPost`, and the "
"only way to get a `PendingReviewPost` is to call the `request_review` method "
"on a `DraftPost`, we’ve now encoded the blog post workflow into the type "
"system."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:935
msgid ""
"But we also have to make some small changes to `main`. The `request_review` "
"and `approve` methods return new instances rather than modifying the struct "
"they’re called on, so we need to add more `let post =` shadowing assignments "
"to save the returned instances. We also can’t have the assertions about the "
"draft and pending review posts’ contents be empty strings, nor do we need "
"them: We can’t compile code that tries to use the content of posts in those "
"states any longer. The updated code in `main` is shown in Listing 18-21."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:963
msgid ""
"The changes we needed to make to `main` to reassign `post` mean that this "
"implementation doesn’t quite follow the object-oriented state pattern "
"anymore: The transformations between the states are no longer encapsulated "
"entirely within the `Post` implementation. However, our gain is that invalid "
"states are now impossible because of the type system and the type checking "
"that happens at compile time! This ensures that certain bugs, such as "
"display of the content of an unpublished post, will be discovered before "
"they make it to production."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:971
msgid ""
"Try the tasks suggested at the start of this section on the `blog` crate as "
"it is after Listing 18-21 to see what you think about the design of this "
"version of the code. Note that some of the tasks might be completed already "
"in this design."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:976
msgid ""
"We’ve seen that even though Rust is capable of implementing object-oriented "
"design patterns, other patterns, such as encoding state into the type "
"system, are also available in Rust. These patterns have different trade-"
"offs. Although you might be very familiar with object-oriented patterns, "
"rethinking the problem to take advantage of Rust’s features can provide "
"benefits, such as preventing some bugs at compile time. Object-oriented "
"patterns won’t always be the best solution in Rust due to certain features, "
"like ownership, that object-oriented languages don’t have."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:985
msgid "Summary"
msgstr ""

#: src/ch18-03-oo-design-patterns.md:987
msgid ""
"Regardless of whether you think Rust is an object-oriented language after "
"reading this chapter, you now know that you can use trait objects to get "
"some object-oriented features in Rust. Dynamic dispatch can give your code "
"some flexibility in exchange for a bit of runtime performance. You can use "
"this flexibility to implement object-oriented patterns that can help your "
"code’s maintainability. Rust also has other features, like ownership, that "
"object-oriented languages don’t have. An object-oriented pattern won’t "
"always be the best way to take advantage of Rust’s strengths, but it is an "
"available option."
msgstr ""

#: src/ch18-03-oo-design-patterns.md:997
msgid ""
"Next, we’ll look at patterns, which are another of Rust’s features that "
"enable lots of flexibility. We’ve looked at them briefly throughout the book "
"but haven’t seen their full capability yet. Let’s go!"
msgstr ""
