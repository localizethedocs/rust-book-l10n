msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch05-01-defining-structs.md:1
msgid "Defining and Instantiating Structs"
msgstr ""

#: src/ch05-01-defining-structs.md:3
msgid ""
"Structs are similar to tuples, discussed in [“The Tuple Type”](ch03-02-data-"
"types.html#the-tuple-type)<!--\n"
"ignore --> section, in that both hold multiple related values. Like tuples, "
"the pieces of a struct can be different types. Unlike with tuples, in a "
"struct you’ll name each piece of data so it’s clear what the values mean. "
"Adding these names means that structs are more flexible than tuples: You "
"don’t have to rely on the order of the data to specify or access the values "
"of an instance."
msgstr ""

#: src/ch05-01-defining-structs.md:10
msgid ""
"To define a struct, we enter the keyword `struct` and name the entire "
"struct. A struct’s name should describe the significance of the pieces of "
"data being grouped together. Then, inside curly brackets, we define the "
"names and types of the pieces of data, which we call _fields_. For example, "
"Listing 5-1 shows a struct that stores information about a user account."
msgstr ""

#: src/ch05-01-defining-structs.md:31
msgid ""
"To use a struct after we’ve defined it, we create an _instance_ of that "
"struct by specifying concrete values for each of the fields. We create an "
"instance by stating the name of the struct and then add curly brackets "
"containing _`key: value`_ pairs, where the keys are the names of the fields "
"and the values are the data we want to store in those fields. We don’t have "
"to specify the fields in the same order in which we declared them in the "
"struct. In other words, the struct definition is like a general template for "
"the type, and instances fill in that template with particular data to create "
"values of the type. For example, we can declare a particular user as shown "
"in Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:54 src/ch05-01-defining-structs.md:82
#: src/ch05-01-defining-structs.md:124 src/ch05-01-defining-structs.md:169
#: src/ch05-01-defining-structs.md:211 src/ch05-01-defining-structs.md:246
#: src/ch05-01-defining-structs.md:388
msgid "\"someusername123\""
msgstr ""

#: src/ch05-01-defining-structs.md:55 src/ch05-01-defining-structs.md:83
#: src/ch05-01-defining-structs.md:123 src/ch05-01-defining-structs.md:168
#: src/ch05-01-defining-structs.md:210 src/ch05-01-defining-structs.md:245
#: src/ch05-01-defining-structs.md:389
msgid "\"someone@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:63
msgid ""
"To get a specific value from a struct, we use dot notation. For example, to "
"access this user’s email address, we use `user1.email`. If the instance is "
"mutable, we can change a value by using the dot notation and assigning into "
"a particular field. Listing 5-3 shows how to change the value in the `email` "
"field of a mutable `User` instance."
msgstr ""

#: src/ch05-01-defining-structs.md:87
msgid "\"anotheremail@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:93
msgid ""
"Note that the entire instance must be mutable; Rust doesn’t allow us to mark "
"only certain fields as mutable. As with any expression, we can construct a "
"new instance of the struct as the last expression in the function body to "
"implicitly return that new instance."
msgstr ""

#: src/ch05-01-defining-structs.md:98
msgid ""
"Listing 5-4 shows a `build_user` function that returns a `User` instance "
"with the given email and username. The `active` field gets the value `true`, "
"and the `sign_in_count` gets a value of `1`."
msgstr ""

#: src/ch05-01-defining-structs.md:131
msgid ""
"It makes sense to name the function parameters with the same name as the "
"struct fields, but having to repeat the `email` and `username` field names "
"and variables is a bit tedious. If the struct had more fields, repeating "
"each name would get even more annoying. Luckily, there’s a convenient "
"shorthand!"
msgstr ""

#: src/ch05-01-defining-structs.md:138
msgid ""
"<a id=\"using-the-field-init-shorthand-when-variables-and-fields-have-the-"
"same-name\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:140
msgid "Using the Field Init Shorthand"
msgstr ""

#: src/ch05-01-defining-structs.md:142
msgid ""
"Because the parameter names and the struct field names are exactly the same "
"in Listing 5-4, we can use the _field init shorthand_ syntax to rewrite "
"`build_user` so that it behaves exactly the same but doesn’t have the "
"repetition of `username` and `email`, as shown in Listing 5-5."
msgstr ""

#: src/ch05-01-defining-structs.md:176
msgid ""
"Here, we’re creating a new instance of the `User` struct, which has a field "
"named `email`. We want to set the `email` field’s value to the value in the "
"`email` parameter of the `build_user` function. Because the `email` field "
"and the `email` parameter have the same name, we only need to write `email` "
"rather than `email: email`."
msgstr ""

#: src/ch05-01-defining-structs.md:184
msgid ""
"<a id=\"creating-instances-from-other-instances-with-struct-update-"
"syntax\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:186
msgid "Creating Instances with Struct Update Syntax"
msgstr ""

#: src/ch05-01-defining-structs.md:188
msgid ""
"It’s often useful to create a new instance of a struct that includes most of "
"the values from another instance of the same type, but changes some of them. "
"You can do this using struct update syntax."
msgstr ""

#: src/ch05-01-defining-structs.md:192
msgid ""
"First, in Listing 5-6 we show how to create a new `User` instance in `user2` "
"in the regular way, without the update syntax. We set a new value for "
"`email` but otherwise use the same values from `user1` that we created in "
"Listing 5-2."
msgstr ""

#: src/ch05-01-defining-structs.md:207 src/ch05-01-defining-structs.md:242
msgid "// --snip--\n"
msgstr ""

#: src/ch05-01-defining-structs.md:219 src/ch05-01-defining-structs.md:252
msgid "\"another@example.com\""
msgstr ""

#: src/ch05-01-defining-structs.md:227
msgid ""
"Using struct update syntax, we can achieve the same effect with less code, "
"as shown in Listing 5-7. The syntax `..` specifies that the remaining fields "
"not explicitly set should have the same value as the fields in the given "
"instance."
msgstr ""

#: src/ch05-01-defining-structs.md:260
msgid ""
"The code in Listing 5-7 also creates an instance in `user2` that has a "
"different value for `email` but has the same values for the `username`, "
"`active`, and `sign_in_count` fields from `user1`. The `..user1` must come "
"last to specify that any remaining fields should get their values from the "
"corresponding fields in `user1`, but we can choose to specify values for as "
"many fields as we want in any order, regardless of the order of the fields "
"in the struct’s definition."
msgstr ""

#: src/ch05-01-defining-structs.md:268
msgid ""
"Note that the struct update syntax uses `=` like an assignment; this is "
"because it moves the data, just as we saw in the [“Variables and Data "
"Interacting with Move”](ch04-01-what-is-ownership.html#variables-and-data-"
"interacting-with-move)<!-- ignore --> section. In this example, we can no "
"longer use `user1` after creating `user2` because the `String` in the "
"`username` field of `user1` was moved into `user2`. If we had given `user2` "
"new `String` values for both `email` and `username`, and thus only used the "
"`active` and `sign_in_count` values from `user1`, then `user1` would still "
"be valid after creating `user2`. Both `active` and `sign_in_count` are types "
"that implement the `Copy` trait, so the behavior we discussed in the [“Stack-"
"Only Data: Copy”](ch04-01-what-is-ownership.html#stack-only-data-copy)<!-- "
"ignore --> section would apply. We can also still use `user1.email` in this "
"example, because its value was not moved out of `user1`."
msgstr ""

#: src/ch05-01-defining-structs.md:282
msgid ""
"<a id=\"using-tuple-structs-without-named-fields-to-create-different-"
"types\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:284
msgid "Creating Different Types with Tuple Structs"
msgstr ""

#: src/ch05-01-defining-structs.md:286
msgid ""
"Rust also supports structs that look similar to tuples, called _tuple "
"structs_. Tuple structs have the added meaning the struct name provides but "
"don’t have names associated with their fields; rather, they just have the "
"types of the fields. Tuple structs are useful when you want to give the "
"whole tuple a name and make the tuple a different type from other tuples, "
"and when naming each field as in a regular struct would be verbose or "
"redundant."
msgstr ""

#: src/ch05-01-defining-structs.md:293
msgid ""
"To define a tuple struct, start with the `struct` keyword and the struct "
"name followed by the types in the tuple. For example, here we define and use "
"two tuple structs named `Color` and `Point`:"
msgstr ""

#: src/ch05-01-defining-structs.md:311
msgid ""
"Note that the `black` and `origin` values are different types because "
"they’re instances of different tuple structs. Each struct you define is its "
"own type, even though the fields within the struct might have the same "
"types. For example, a function that takes a parameter of type `Color` cannot "
"take a `Point` as an argument, even though both types are made up of three "
"`i32` values. Otherwise, tuple struct instances are similar to tuples in "
"that you can destructure them into their individual pieces, and you can use "
"a `.` followed by the index to access an individual value. Unlike tuples, "
"tuple structs require you to name the type of the struct when you "
"destructure them. For example, we would write `let Point(x, y, z) = origin;` "
"to destructure the values in the `origin` point into variables named `x`, "
"`y`, and `z`."
msgstr ""

#: src/ch05-01-defining-structs.md:325
msgid "<a id=\"unit-like-structs-without-any-fields\"></a>"
msgstr ""

#: src/ch05-01-defining-structs.md:327
msgid "Defining Unit-Like Structs"
msgstr ""

#: src/ch05-01-defining-structs.md:329
msgid ""
"You can also define structs that don’t have any fields! These are called "
"_unit-like structs_ because they behave similarly to `()`, the unit type "
"that we mentioned in [“The Tuple Type”](ch03-02-data-types.html#the-tuple-"
"type)<!-- ignore --> section. Unit-like structs can be useful when you need "
"to implement a trait on some type but don’t have any data that you want to "
"store in the type itself. We’ll discuss traits in Chapter 10. Here’s an "
"example of declaring and instantiating a unit struct named `AlwaysEqual`:"
msgstr ""

#: src/ch05-01-defining-structs.md:349
msgid ""
"To define `AlwaysEqual`, we use the `struct` keyword, the name we want, and "
"then a semicolon. No need for curly brackets or parentheses! Then, we can "
"get an instance of `AlwaysEqual` in the `subject` variable in a similar way: "
"using the name we defined, without any curly brackets or parentheses. "
"Imagine that later we’ll implement behavior for this type such that every "
"instance of `AlwaysEqual` is always equal to every instance of any other "
"type, perhaps to have a known result for testing purposes. We wouldn’t need "
"any data to implement that behavior! You’ll see in Chapter 10 how to define "
"traits and implement them on any type, including unit-like structs."
msgstr ""

#: src/ch05-01-defining-structs.md:359
msgid "Ownership of Struct Data"
msgstr ""

#: src/ch05-01-defining-structs.md:361
msgid ""
"In the `User` struct definition in Listing 5-1, we used the owned `String` "
"type rather than the `&str` string slice type. This is a deliberate choice "
"because we want each instance of this struct to own all of its data and for "
"that data to be valid for as long as the entire struct is valid."
msgstr ""

#: src/ch05-01-defining-structs.md:366
msgid ""
"It’s also possible for structs to store references to data owned by "
"something else, but to do so requires the use of _lifetimes_, a Rust feature "
"that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced "
"by a struct is valid for as long as the struct is. Let’s say you try to "
"store a reference in a struct without specifying lifetimes, like the "
"following in _src/main.rs_; this won’t work:"
msgstr ""

#: src/ch05-01-defining-structs.md:397
msgid "The compiler will complain that it needs lifetime specifiers:"
msgstr ""

#: src/ch05-01-defining-structs.md:399
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling structs v0.1.0 (file:///projects/structs)\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:3:15\n"
"  |\n"
"3 |     username: &str,\n"
"  |               ^ expected named lifetime parameter\n"
"  |\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"1 ~ struct User<'a> {\n"
"2 |     active: bool,\n"
"3 ~     username: &'a str,\n"
"  |\n"
"\n"
"error[E0106]: missing lifetime specifier\n"
" --> src/main.rs:4:12\n"
"  |\n"
"4 |     email: &str,\n"
"  |            ^ expected named lifetime parameter\n"
"  |\n"
"help: consider introducing a named lifetime parameter\n"
"  |\n"
"1 ~ struct User<'a> {\n"
"2 |     active: bool,\n"
"3 |     username: &str,\n"
"4 ~     email: &'a str,\n"
"  |\n"
"\n"
"For more information about this error, try `rustc --explain E0106`.\n"
"error: could not compile `structs` (bin \"structs\") due to 2 previous "
"errors\n"
"```"
msgstr ""

#: src/ch05-01-defining-structs.md:433
msgid ""
"In Chapter 10, we’ll discuss how to fix these errors so that you can store "
"references in structs, but for now, we’ll fix errors like these using owned "
"types like `String` instead of references like `&str`."
msgstr ""
