msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch20-02-advanced-traits.md:1
msgid "Advanced Traits"
msgstr ""

#: src/ch20-02-advanced-traits.md:3
msgid ""
"We first covered traits in the [“Defining Shared Behavior with Traits”]"
"(ch10-02-traits.html)<!-- ignore --> section in Chapter 10, but we didn’t "
"discuss the more advanced details. Now that you know more about Rust, we can "
"get into the nitty-gritty."
msgstr ""

#: src/ch20-02-advanced-traits.md:10
msgid ""
"<a id=\"specifying-placeholder-types-in-trait-definitions-with-associated-"
"types\"></a> <a id=\"associated-types\"></a>"
msgstr ""

#: src/ch20-02-advanced-traits.md:13
msgid "Defining Traits with Associated Types"
msgstr ""

#: src/ch20-02-advanced-traits.md:15
msgid ""
"_Associated types_ connect a type placeholder with a trait such that the "
"trait method definitions can use these placeholder types in their "
"signatures. The implementor of a trait will specify the concrete type to be "
"used instead of the placeholder type for the particular implementation. That "
"way, we can define a trait that uses some types without needing to know "
"exactly what those types are until the trait is implemented."
msgstr ""

#: src/ch20-02-advanced-traits.md:22
msgid ""
"We’ve described most of the advanced features in this chapter as being "
"rarely needed. Associated types are somewhere in the middle: They’re used "
"more rarely than features explained in the rest of the book but more "
"commonly than many of the other features discussed in this chapter."
msgstr ""

#: src/ch20-02-advanced-traits.md:27
msgid ""
"One example of a trait with an associated type is the `Iterator` trait that "
"the standard library provides. The associated type is named `Item` and "
"stands in for the type of the values the type implementing the `Iterator` "
"trait is iterating over. The definition of the `Iterator` trait is as shown "
"in Listing 20-13."
msgstr ""

#: src/ch20-02-advanced-traits.md:45
msgid ""
"The type `Item` is a placeholder, and the `next` method’s definition shows "
"that it will return values of type `Option<Self::Item>`. Implementors of the "
"`Iterator` trait will specify the concrete type for `Item`, and the `next` "
"method will return an `Option` containing a value of that concrete type."
msgstr ""

#: src/ch20-02-advanced-traits.md:50
msgid ""
"Associated types might seem like a similar concept to generics, in that the "
"latter allow us to define a function without specifying what types it can "
"handle. To examine the difference between the two concepts, we’ll look at an "
"implementation of the `Iterator` trait on a type named `Counter` that "
"specifies the `Item` type is `u32`:"
msgstr ""

#: src/ch20-02-advanced-traits.md:73
msgid "// --snip--\n"
msgstr ""

#: src/ch20-02-advanced-traits.md:86
msgid ""
"This syntax seems comparable to that of generics. So, why not just define "
"the `Iterator` trait with generics, as shown in Listing 20-14?"
msgstr ""

#: src/ch20-02-advanced-traits.md:99
msgid ""
"The difference is that when using generics, as in Listing 20-14, we must "
"annotate the types in each implementation; because we can also implement "
"`Iterator<String> for Counter` or any other type, we could have multiple "
"implementations of `Iterator` for `Counter`. In other words, when a trait "
"has a generic parameter, it can be implemented for a type multiple times, "
"changing the concrete types of the generic type parameters each time. When "
"we use the `next` method on `Counter`, we would have to provide type "
"annotations to indicate which implementation of `Iterator` we want to use."
msgstr ""

#: src/ch20-02-advanced-traits.md:108
msgid ""
"With associated types, we don’t need to annotate types, because we can’t "
"implement a trait on a type multiple times. In Listing 20-13 with the "
"definition that uses associated types, we can choose what the type of `Item` "
"will be only once because there can be only one `impl Iterator for Counter`. "
"We don’t have to specify that we want an iterator of `u32` values everywhere "
"we call `next` on `Counter`."
msgstr ""

#: src/ch20-02-advanced-traits.md:115
msgid ""
"Associated types also become part of the trait’s contract: Implementors of "
"the trait must provide a type to stand in for the associated type "
"placeholder. Associated types often have a name that describes how the type "
"will be used, and documenting the associated type in the API documentation "
"is a good practice."
msgstr ""

#: src/ch20-02-advanced-traits.md:122
msgid "<a id=\"default-generic-type-parameters-and-operator-overloading\"></a>"
msgstr ""

#: src/ch20-02-advanced-traits.md:124
msgid "Using Default Generic Parameters and Operator Overloading"
msgstr ""

#: src/ch20-02-advanced-traits.md:126
msgid ""
"When we use generic type parameters, we can specify a default concrete type "
"for the generic type. This eliminates the need for implementors of the trait "
"to specify a concrete type if the default type works. You specify a default "
"type when declaring a generic type with the `<PlaceholderType=ConcreteType>` "
"syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:131
msgid ""
"A great example of a situation where this technique is useful is with "
"_operator overloading_, in which you customize the behavior of an operator "
"(such as `+`) in particular situations."
msgstr ""

#: src/ch20-02-advanced-traits.md:135
msgid ""
"Rust doesn’t allow you to create your own operators or overload arbitrary "
"operators. But you can overload the operations and corresponding traits "
"listed in `std::ops` by implementing the traits associated with the "
"operator. For example, in Listing 20-15, we overload the `+` operator to add "
"two `Point` instances together. We do this by implementing the `Add` trait "
"on a `Point` struct."
msgstr ""

#: src/ch20-02-advanced-traits.md:174
msgid ""
"The `add` method adds the `x` values of two `Point` instances and the `y` "
"values of two `Point` instances to create a new `Point`. The `Add` trait has "
"an associated type named `Output` that determines the type returned from the "
"`add` method."
msgstr ""

#: src/ch20-02-advanced-traits.md:179
msgid ""
"The default generic type in this code is within the `Add` trait. Here is its "
"definition:"
msgstr ""

#: src/ch20-02-advanced-traits.md:190
msgid ""
"This code should look generally familiar: a trait with one method and an "
"associated type. The new part is `Rhs=Self`: This syntax is called _default "
"type parameters_. The `Rhs` generic type parameter (short for “right-hand "
"side”) defines the type of the `rhs` parameter in the `add` method. If we "
"don’t specify a concrete type for `Rhs` when we implement the `Add` trait, "
"the type of `Rhs` will default to `Self`, which will be the type we’re "
"implementing `Add` on."
msgstr ""

#: src/ch20-02-advanced-traits.md:198
msgid ""
"When we implemented `Add` for `Point`, we used the default for `Rhs` because "
"we wanted to add two `Point` instances. Let’s look at an example of "
"implementing the `Add` trait where we want to customize the `Rhs` type "
"rather than using the default."
msgstr ""

#: src/ch20-02-advanced-traits.md:203
msgid ""
"We have two structs, `Millimeters` and `Meters`, holding values in different "
"units. This thin wrapping of an existing type in another struct is known as "
"the _newtype pattern_, which we describe in more detail in the "
"[“Implementing External Traits with the Newtype Pattern”](ch20-02-advanced-"
"traits.html#implementing-external-traits-with-the-newtype-pattern)<!-- "
"ignore --> section. We want to add values in millimeters to values in meters "
"and have the implementation of `Add` do the conversion correctly. We can "
"implement `Add` for `Millimeters` with `Meters` as the `Rhs`, as shown in "
"Listing 20-16."
msgstr ""

#: src/ch20-02-advanced-traits.md:230
msgid ""
"To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the "
"value of the `Rhs` type parameter instead of using the default of `Self`."
msgstr ""

#: src/ch20-02-advanced-traits.md:233
msgid "You’ll use default type parameters in two main ways:"
msgstr ""

#: src/ch20-02-advanced-traits.md:235
msgid "To extend a type without breaking existing code"
msgstr ""

#: src/ch20-02-advanced-traits.md:236
msgid "To allow customization in specific cases most users won’t need"
msgstr ""

#: src/ch20-02-advanced-traits.md:238
msgid ""
"The standard library’s `Add` trait is an example of the second purpose: "
"Usually, you’ll add two like types, but the `Add` trait provides the ability "
"to customize beyond that. Using a default type parameter in the `Add` trait "
"definition means you don’t have to specify the extra parameter most of the "
"time. In other words, a bit of implementation boilerplate isn’t needed, "
"making it easier to use the trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:245
msgid ""
"The first purpose is similar to the second but in reverse: If you want to "
"add a type parameter to an existing trait, you can give it a default to "
"allow extension of the functionality of the trait without breaking the "
"existing implementation code."
msgstr ""

#: src/ch20-02-advanced-traits.md:252
msgid ""
"<a id=\"fully-qualified-syntax-for-disambiguation-calling-methods-with-the-"
"same-name\"></a> <a id=\"disambiguating-between-methods-with-the-same-"
"name\"></a>"
msgstr ""

#: src/ch20-02-advanced-traits.md:255
msgid "Disambiguating Between Identically Named Methods"
msgstr ""

#: src/ch20-02-advanced-traits.md:257
msgid ""
"Nothing in Rust prevents a trait from having a method with the same name as "
"another trait’s method, nor does Rust prevent you from implementing both "
"traits on one type. It’s also possible to implement a method directly on the "
"type with the same name as methods from traits."
msgstr ""

#: src/ch20-02-advanced-traits.md:262
msgid ""
"When calling methods with the same name, you’ll need to tell Rust which one "
"you want to use. Consider the code in Listing 20-17 where we’ve defined two "
"traits, `Pilot` and `Wizard`, that both have a method called `fly`. We then "
"implement both traits on a type `Human` that already has a method named "
"`fly` implemented on it. Each `fly` method does something different."
msgstr ""

#: src/ch20-02-advanced-traits.md:283 src/ch20-02-advanced-traits.md:322
#: src/ch20-02-advanced-traits.md:368
msgid "\"This is your captain speaking.\""
msgstr ""

#: src/ch20-02-advanced-traits.md:289 src/ch20-02-advanced-traits.md:328
#: src/ch20-02-advanced-traits.md:374
msgid "\"Up!\""
msgstr ""

#: src/ch20-02-advanced-traits.md:295 src/ch20-02-advanced-traits.md:334
#: src/ch20-02-advanced-traits.md:380
msgid "\"*waving arms furiously*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:304
msgid ""
"When we call `fly` on an instance of `Human`, the compiler defaults to "
"calling the method that is directly implemented on the type, as shown in "
"Listing 20-18."
msgstr ""

#: src/ch20-02-advanced-traits.md:346
msgid ""
"Running this code will print `*waving arms furiously*`, showing that Rust "
"called the `fly` method implemented on `Human` directly."
msgstr ""

#: src/ch20-02-advanced-traits.md:349
msgid ""
"To call the `fly` methods from either the `Pilot` trait or the `Wizard` "
"trait, we need to use more explicit syntax to specify which `fly` method we "
"mean. Listing 20-19 demonstrates this syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:394
msgid ""
"Specifying the trait name before the method name clarifies to Rust which "
"implementation of `fly` we want to call. We could also write `Human::"
"fly(&person)`, which is equivalent to the `person.fly()` that we used in "
"Listing 20-19, but this is a bit longer to write if we don’t need to "
"disambiguate."
msgstr ""

#: src/ch20-02-advanced-traits.md:400
msgid "Running this code prints the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:402
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n"
"     Running `target/debug/traits-example`\n"
"This is your captain speaking.\n"
"Up!\n"
"*waving arms furiously*\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:412
msgid ""
"Because the `fly` method takes a `self` parameter, if we had two _types_ "
"that both implement one _trait_, Rust could figure out which implementation "
"of a trait to use based on the type of `self`."
msgstr ""

#: src/ch20-02-advanced-traits.md:416
msgid ""
"However, associated functions that are not methods don’t have a `self` "
"parameter. When there are multiple types or traits that define non-method "
"functions with the same function name, Rust doesn’t always know which type "
"you mean unless you use fully qualified syntax. For example, in Listing "
"20-20, we create a trait for an animal shelter that wants to name all baby "
"dogs Spot. We make an `Animal` trait with an associated non-method function "
"`baby_name`. The `Animal` trait is implemented for the struct `Dog`, on "
"which we also provide an associated non-method function `baby_name` directly."
msgstr ""

#: src/ch20-02-advanced-traits.md:436 src/ch20-02-advanced-traits.md:487
#: src/ch20-02-advanced-traits.md:545
msgid "\"Spot\""
msgstr ""

#: src/ch20-02-advanced-traits.md:442 src/ch20-02-advanced-traits.md:493
#: src/ch20-02-advanced-traits.md:551
msgid "\"puppy\""
msgstr ""

#: src/ch20-02-advanced-traits.md:447 src/ch20-02-advanced-traits.md:498
#: src/ch20-02-advanced-traits.md:556
msgid "\"A baby dog is called a {}\""
msgstr ""

#: src/ch20-02-advanced-traits.md:453
msgid ""
"We implement the code for naming all puppies Spot in the `baby_name` "
"associated function that is defined on `Dog`. The `Dog` type also implements "
"the trait `Animal`, which describes characteristics that all animals have. "
"Baby dogs are called puppies, and that is expressed in the implementation of "
"the `Animal` trait on `Dog` in the `baby_name` function associated with the "
"`Animal` trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:459
msgid ""
"In `main`, we call the `Dog::baby_name` function, which calls the associated "
"function defined on `Dog` directly. This code prints the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:462
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a Spot\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:470
msgid ""
"This output isn’t what we wanted. We want to call the `baby_name` function "
"that is part of the `Animal` trait that we implemented on `Dog` so that the "
"code prints `A baby dog is called a puppy`. The technique of specifying the "
"trait name that we used in Listing 20-19 doesn’t help here; if we change "
"`main` to the code in Listing 20-21, we’ll get a compilation error."
msgstr ""

#: src/ch20-02-advanced-traits.md:504
msgid ""
"Because `Animal::baby_name` doesn’t have a `self` parameter, and there could "
"be other types that implement the `Animal` trait, Rust can’t figure out "
"which implementation of `Animal::baby_name` we want. We’ll get this compiler "
"error:"
msgstr ""

#: src/ch20-02-advanced-traits.md:508
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0790]: cannot call associated function on trait without specifying "
"the corresponding `impl` type\n"
"  --> src/main.rs:20:43\n"
"   |\n"
" 2 |     fn baby_name() -> String;\n"
"   |     ------------------------- `Animal::baby_name` defined here\n"
"...\n"
"20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n"
"   |                                           ^^^^^^^^^^^^^^^^^^^ cannot "
"call associated function of trait\n"
"   |\n"
"help: use the fully-qualified path to the only available implementation\n"
"   |\n"
"20 |     println!(\"A baby dog is called a {}\", <Dog as Animal>::"
"baby_name());\n"
"   |                                           +++++++       +\n"
"\n"
"For more information about this error, try `rustc --explain E0790`.\n"
"error: could not compile `traits-example` (bin \"traits-example\") due to 1 "
"previous error\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:529
msgid ""
"To disambiguate and tell Rust that we want to use the implementation of "
"`Animal` for `Dog` as opposed to the implementation of `Animal` for some "
"other type, we need to use fully qualified syntax. Listing 20-22 "
"demonstrates how to use fully qualified syntax."
msgstr ""

#: src/ch20-02-advanced-traits.md:562
msgid ""
"We’re providing Rust with a type annotation within the angle brackets, which "
"indicates we want to call the `baby_name` method from the `Animal` trait as "
"implemented on `Dog` by saying that we want to treat the `Dog` type as an "
"`Animal` for this function call. This code will now print what we want:"
msgstr ""

#: src/ch20-02-advanced-traits.md:567
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n"
"     Running `target/debug/traits-example`\n"
"A baby dog is called a puppy\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:575
msgid "In general, fully qualified syntax is defined as follows:"
msgstr ""

#: src/ch20-02-advanced-traits.md:581
msgid ""
"For associated functions that aren’t methods, there would not be a "
"`receiver`: There would only be the list of other arguments. You could use "
"fully qualified syntax everywhere that you call functions or methods. "
"However, you’re allowed to omit any part of this syntax that Rust can figure "
"out from other information in the program. You only need to use this more "
"verbose syntax in cases where there are multiple implementations that use "
"the same name and Rust needs help to identify which implementation you want "
"to call."
msgstr ""

#: src/ch20-02-advanced-traits.md:591
msgid ""
"<a id=\"using-supertraits-to-require-one-traits-functionality-within-another-"
"trait\"></a>"
msgstr ""

#: src/ch20-02-advanced-traits.md:593
msgid "Using Supertraits"
msgstr ""

#: src/ch20-02-advanced-traits.md:595
msgid ""
"Sometimes you might write a trait definition that depends on another trait: "
"For a type to implement the first trait, you want to require that type to "
"also implement the second trait. You would do this so that your trait "
"definition can make use of the associated items of the second trait. The "
"trait your trait definition is relying on is called a _supertrait_ of your "
"trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:601
msgid ""
"For example, let’s say we want to make an `OutlinePrint` trait with an "
"`outline_print` method that will print a given value formatted so that it’s "
"framed in asterisks. That is, given a `Point` struct that implements the "
"standard library trait `Display` to result in `(x, y)`, when we call "
"`outline_print` on a `Point` instance that has `1` for `x` and `3` for `y`, "
"it should print the following:"
msgstr ""

#: src/ch20-02-advanced-traits.md:616
msgid ""
"In the implementation of the `outline_print` method, we want to use the "
"`Display` trait’s functionality. Therefore, we need to specify that the "
"`OutlinePrint` trait will work only for types that also implement `Display` "
"and provide the functionality that `OutlinePrint` needs. We can do that in "
"the trait definition by specifying `OutlinePrint: Display`. This technique "
"is similar to adding a trait bound to the trait. Listing 20-23 shows an "
"implementation of the `OutlinePrint` trait."
msgstr ""

#: src/ch20-02-advanced-traits.md:633 src/ch20-02-advanced-traits.md:637
#: src/ch20-02-advanced-traits.md:665 src/ch20-02-advanced-traits.md:669
#: src/ch20-02-advanced-traits.md:733 src/ch20-02-advanced-traits.md:737
msgid "\"{}\""
msgstr ""

#: src/ch20-02-advanced-traits.md:633 src/ch20-02-advanced-traits.md:637
#: src/ch20-02-advanced-traits.md:665 src/ch20-02-advanced-traits.md:669
#: src/ch20-02-advanced-traits.md:733 src/ch20-02-advanced-traits.md:737
msgid "\"*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:634 src/ch20-02-advanced-traits.md:636
#: src/ch20-02-advanced-traits.md:666 src/ch20-02-advanced-traits.md:668
#: src/ch20-02-advanced-traits.md:734 src/ch20-02-advanced-traits.md:736
msgid "\"*{}*\""
msgstr ""

#: src/ch20-02-advanced-traits.md:634 src/ch20-02-advanced-traits.md:636
#: src/ch20-02-advanced-traits.md:666 src/ch20-02-advanced-traits.md:668
#: src/ch20-02-advanced-traits.md:734 src/ch20-02-advanced-traits.md:736
msgid "\" \""
msgstr ""

#: src/ch20-02-advanced-traits.md:635 src/ch20-02-advanced-traits.md:667
#: src/ch20-02-advanced-traits.md:735
msgid "\"* {output} *\""
msgstr ""

#: src/ch20-02-advanced-traits.md:646
msgid ""
"Because we’ve specified that `OutlinePrint` requires the `Display` trait, we "
"can use the `to_string` function that is automatically implemented for any "
"type that implements `Display`. If we tried to use `to_string` without "
"adding a colon and specifying the `Display` trait after the trait name, we’d "
"get an error saying that no method named `to_string` was found for the type "
"`&Self` in the current scope."
msgstr ""

#: src/ch20-02-advanced-traits.md:653
msgid ""
"Let’s see what happens when we try to implement `OutlinePrint` on a type "
"that doesn’t implement `Display`, such as the `Point` struct:"
msgstr ""

#: src/ch20-02-advanced-traits.md:688
msgid "We get an error saying that `Display` is required but not implemented:"
msgstr ""

#: src/ch20-02-advanced-traits.md:690
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n"
"error[E0277]: `Point` doesn't implement `std::fmt::Display`\n"
"  --> src/main.rs:20:23\n"
"   |\n"
"20 | impl OutlinePrint for Point {}\n"
"   |                       ^^^^^ the trait `std::fmt::Display` is not "
"implemented for `Point`\n"
"   |\n"
"note: required by a bound in `OutlinePrint`\n"
"  --> src/main.rs:3:21\n"
"   |\n"
" 3 | trait OutlinePrint: fmt::Display {\n"
"   |                     ^^^^^^^^^^^^ required by this bound in "
"`OutlinePrint`\n"
"\n"
"error[E0277]: `Point` doesn't implement `std::fmt::Display`\n"
"  --> src/main.rs:24:7\n"
"   |\n"
"24 |     p.outline_print();\n"
"   |       ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented "
"for `Point`\n"
"   |\n"
"note: required by a bound in `OutlinePrint::outline_print`\n"
"  --> src/main.rs:3:21\n"
"   |\n"
" 3 | trait OutlinePrint: fmt::Display {\n"
"   |                     ^^^^^^^^^^^^ required by this bound in "
"`OutlinePrint::outline_print`\n"
" 4 |     fn outline_print(&self) {\n"
"   |        ------------- required by a bound in this associated function\n"
"\n"
"For more information about this error, try `rustc --explain E0277`.\n"
"error: could not compile `traits-example` (bin \"traits-example\") due to 2 "
"previous errors\n"
"```"
msgstr ""

#: src/ch20-02-advanced-traits.md:723
msgid ""
"To fix this, we implement `Display` on `Point` and satisfy the constraint "
"that `OutlinePrint` requires, like so:"
msgstr ""

#: src/ch20-02-advanced-traits.md:752
msgid "\"({}, {})\""
msgstr ""

#: src/ch20-02-advanced-traits.md:764
msgid ""
"Then, implementing the `OutlinePrint` trait on `Point` will compile "
"successfully, and we can call `outline_print` on a `Point` instance to "
"display it within an outline of asterisks."
msgstr ""

#: src/ch20-02-advanced-traits.md:770
msgid ""
"<a id=\"using-the-newtype-pattern-to-implement-external-traits-on-external-"
"types\"></a> <a id=\"using-the-newtype-pattern-to-implement-external-"
"traits\"></a>"
msgstr ""

#: src/ch20-02-advanced-traits.md:773
msgid "Implementing External Traits with the Newtype Pattern"
msgstr ""

#: src/ch20-02-advanced-traits.md:775
msgid ""
"In the [“Implementing a Trait on a Type”](ch10-02-traits.html#implementing-a-"
"trait-on-a-type)<!--\n"
"ignore --> section in Chapter 10, we mentioned the orphan rule that states "
"we’re only allowed to implement a trait on a type if either the trait or the "
"type, or both, are local to our crate. It’s possible to get around this "
"restriction using the newtype pattern, which involves creating a new type in "
"a tuple struct. (We covered tuple structs in the [“Creating Different Types "
"with Tuple Structs”](ch05-01-defining-structs.html#creating-different-types-"
"with-tuple-structs)<!-- ignore --> section in Chapter 5.) The tuple struct "
"will have one field and be a thin wrapper around the type for which we want "
"to implement a trait. Then, the wrapper type is local to our crate, and we "
"can implement the trait on the wrapper. _Newtype_ is a term that originates "
"from the Haskell programming language. There is no runtime performance "
"penalty for using this pattern, and the wrapper type is elided at compile "
"time."
msgstr ""

#: src/ch20-02-advanced-traits.md:788
msgid ""
"As an example, let’s say we want to implement `Display` on `Vec<T>`, which "
"the orphan rule prevents us from doing directly because the `Display` trait "
"and the `Vec<T>` type are defined outside our crate. We can make a `Wrapper` "
"struct that holds an instance of `Vec<T>`; then, we can implement `Display` "
"on `Wrapper` and use the `Vec<T>` value, as shown in Listing 20-24."
msgstr ""

#: src/ch20-02-advanced-traits.md:803
msgid "\"[{}]\""
msgstr ""

#: src/ch20-02-advanced-traits.md:803
msgid "\", \""
msgstr ""

#: src/ch20-02-advanced-traits.md:808
msgid "\"hello\""
msgstr ""

#: src/ch20-02-advanced-traits.md:808
msgid "\"world\""
msgstr ""

#: src/ch20-02-advanced-traits.md:809
msgid "\"w = {w}\""
msgstr ""

#: src/ch20-02-advanced-traits.md:815
msgid ""
"The implementation of `Display` uses `self.0` to access the inner `Vec<T>` "
"because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in "
"the tuple. Then, we can use the functionality of the `Display` trait on "
"`Wrapper`."
msgstr ""

#: src/ch20-02-advanced-traits.md:819
msgid ""
"The downside of using this technique is that `Wrapper` is a new type, so it "
"doesn’t have the methods of the value it’s holding. We would have to "
"implement all the methods of `Vec<T>` directly on `Wrapper` such that the "
"methods delegate to `self.0`, which would allow us to treat `Wrapper` "
"exactly like a `Vec<T>`. If we wanted the new type to have every method the "
"inner type has, implementing the `Deref` trait on the `Wrapper` to return "
"the inner type would be a solution (we discussed implementing the `Deref` "
"trait in the [“Treating Smart Pointers Like Regular References”](ch15-02-"
"deref.html#treating-smart-pointers-like-regular-references)<!-- ignore --> "
"section in Chapter 15). If we didn’t want the `Wrapper` type to have all the "
"methods of the inner type—for example, to restrict the `Wrapper` type’s "
"behavior—we would have to implement just the methods we do want manually."
msgstr ""

#: src/ch20-02-advanced-traits.md:831
msgid ""
"This newtype pattern is also useful even when traits are not involved. Let’s "
"switch focus and look at some advanced ways to interact with Rust’s type "
"system."
msgstr ""
