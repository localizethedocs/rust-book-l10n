msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch17-03-more-futures.md:4
msgid "<a id=\"yielding\"></a>"
msgstr ""

#: src/ch17-03-more-futures.md:6
msgid "Yielding Control to the Runtime"
msgstr ""

#: src/ch17-03-more-futures.md:8
msgid ""
"Recall from the [“Our First Async Program”](ch17-01-futures-and-syntax."
"html#our-first-async-program)<!-- ignore --> section that at each await "
"point, Rust gives a runtime a chance to pause the task and switch to another "
"one if the future being awaited isn’t ready. The inverse is also true: Rust "
"_only_ pauses async blocks and hands control back to a runtime at an await "
"point. Everything between await points is synchronous."
msgstr ""

#: src/ch17-03-more-futures.md:14
msgid ""
"That means if you do a bunch of work in an async block without an await "
"point, that future will block any other futures from making progress. You "
"may sometimes hear this referred to as one future _starving_ other futures. "
"In some cases, that may not be a big deal. However, if you are doing some "
"kind of expensive setup or long-running work, or if you have a future that "
"will keep doing some particular task indefinitely, you’ll need to think "
"about when and where to hand control back to the runtime."
msgstr ""

#: src/ch17-03-more-futures.md:22
msgid ""
"Let’s simulate a long-running operation to illustrate the starvation "
"problem, then explore how to solve it. Listing 17-14 introduces a `slow` "
"function."
msgstr ""

#: src/ch17-03-more-futures.md:28 src/ch17-03-more-futures.md:57
#: src/ch17-03-more-futures.md:134 src/ch17-03-more-futures.md:213
#: src/ch17-03-more-futures.md:293 src/ch17-03-more-futures.md:335
#: src/ch17-03-more-futures.md:376
msgid "// required for mdbook test\n"
msgstr ""

#: src/ch17-03-more-futures.md:34
msgid "// We will call `slow` here later\n"
msgstr ""

#: src/ch17-03-more-futures.md:40 src/ch17-03-more-futures.md:88
#: src/ch17-03-more-futures.md:172 src/ch17-03-more-futures.md:249
msgid "\"'{name}' ran for {ms}ms\""
msgstr ""

#: src/ch17-03-more-futures.md:46
msgid ""
"This code uses `std::thread::sleep` instead of `trpl::sleep` so that calling "
"`slow` will block the current thread for some number of milliseconds. We can "
"use `slow` to stand in for real-world operations that are both long-running "
"and blocking."
msgstr ""

#: src/ch17-03-more-futures.md:51
msgid ""
"In Listing 17-15, we use `slow` to emulate doing this kind of CPU-bound work "
"in a pair of futures."
msgstr ""

#: src/ch17-03-more-futures.md:64 src/ch17-03-more-futures.md:143
#: src/ch17-03-more-futures.md:220
msgid "\"'a' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:65 src/ch17-03-more-futures.md:66
#: src/ch17-03-more-futures.md:67 src/ch17-03-more-futures.md:144
#: src/ch17-03-more-futures.md:146 src/ch17-03-more-futures.md:148
#: src/ch17-03-more-futures.md:221 src/ch17-03-more-futures.md:223
#: src/ch17-03-more-futures.md:225
msgid "\"a\""
msgstr ""

#: src/ch17-03-more-futures.md:69 src/ch17-03-more-futures.md:150
#: src/ch17-03-more-futures.md:227
msgid "\"'a' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:73 src/ch17-03-more-futures.md:154
#: src/ch17-03-more-futures.md:231
msgid "\"'b' started.\""
msgstr ""

#: src/ch17-03-more-futures.md:74 src/ch17-03-more-futures.md:75
#: src/ch17-03-more-futures.md:76 src/ch17-03-more-futures.md:77
#: src/ch17-03-more-futures.md:155 src/ch17-03-more-futures.md:157
#: src/ch17-03-more-futures.md:159 src/ch17-03-more-futures.md:161
#: src/ch17-03-more-futures.md:232 src/ch17-03-more-futures.md:234
#: src/ch17-03-more-futures.md:236 src/ch17-03-more-futures.md:238
msgid "\"b\""
msgstr ""

#: src/ch17-03-more-futures.md:79 src/ch17-03-more-futures.md:163
#: src/ch17-03-more-futures.md:240
msgid "\"'b' finished.\""
msgstr ""

#: src/ch17-03-more-futures.md:94
msgid ""
"Each future hands control back to the runtime only _after_ carrying out a "
"bunch of slow operations. If you run this code, you will see this output:"
msgstr ""

#: src/ch17-03-more-futures.md:116
msgid ""
"As with Listing 17-5 where we used `trpl::select` to race futures fetching "
"two URLs, `select` still finishes as soon as `a` is done. There’s no "
"interleaving between the calls to `slow` in the two futures, though. The `a` "
"future does all of its work until the `trpl::sleep` call is awaited, then "
"the `b` future does all of its work until its own `trpl::sleep` call is "
"awaited, and finally the `a` future completes. To allow both futures to make "
"progress between their slow tasks, we need await points so we can hand "
"control back to the runtime. That means we need something we can await!"
msgstr ""

#: src/ch17-03-more-futures.md:125
msgid ""
"We can already see this kind of handoff happening in Listing 17-15: if we "
"removed the `trpl::sleep` at the end of the `a` future, it would complete "
"without the `b` future running _at all_. Let’s try using the `trpl::sleep` "
"function as a starting point for letting operations switch off making "
"progress, as shown in Listing 17-16."
msgstr ""

#: src/ch17-03-more-futures.md:178
msgid ""
"We’ve added `trpl::sleep` calls with await points between each call to "
"`slow`. Now the two futures’ work is interleaved:"
msgstr ""

#: src/ch17-03-more-futures.md:199
msgid ""
"The `a` future still runs for a bit before handing off control to `b`, "
"because it calls `slow` before ever calling `trpl::sleep`, but after that "
"the futures swap back and forth each time one of them hits an await point. "
"In this case, we have done that after every call to `slow`, but we could "
"break up the work in whatever way makes the most sense to us."
msgstr ""

#: src/ch17-03-more-futures.md:205
msgid ""
"We don’t really want to _sleep_ here, though: we want to make progress as "
"fast as we can. We just need to hand back control to the runtime. We can do "
"that directly, using the `trpl::yield_now` function. In Listing 17-17, we "
"replace all those `trpl::sleep` calls with `trpl::yield_now`."
msgstr ""

#: src/ch17-03-more-futures.md:255
msgid ""
"This code is both clearer about the actual intent and can be significantly "
"faster than using `sleep`, because timers such as the one used by `sleep` "
"often have limits on how granular they can be. The version of `sleep` we are "
"using, for example, will always sleep for at least a millisecond, even if we "
"pass it a `Duration` of one nanosecond. Again, modern computers are _fast_: "
"they can do a lot in one millisecond!"
msgstr ""

#: src/ch17-03-more-futures.md:262
msgid ""
"This means that async can be useful even for compute-bound tasks, depending "
"on what else your program is doing, because it provides a useful tool for "
"structuring the relationships between different parts of the program (but at "
"a cost of the overhead of the async state machine). This is a form of "
"_cooperative multitasking_, where each future has the power to determine "
"when it hands over control via await points. Each future therefore also has "
"the responsibility to avoid blocking for too long. In some Rust-based "
"embedded operating systems, this is the _only_ kind of multitasking!"
msgstr ""

#: src/ch17-03-more-futures.md:271
msgid ""
"In real-world code, you won’t usually be alternating function calls with "
"await points on every single line, of course. While yielding control in this "
"way is relatively inexpensive, it’s not free. In many cases, trying to break "
"up a compute-bound task might make it significantly slower, so sometimes "
"it’s better for _overall_ performance to let an operation block briefly. "
"Always measure to see what your code’s actual performance bottlenecks are. "
"The underlying dynamic is important to keep in mind, though, if you _are_ "
"seeing a lot of work happening in serial that you expected to happen "
"concurrently!"
msgstr ""

#: src/ch17-03-more-futures.md:280
msgid "Building Our Own Async Abstractions"
msgstr ""

#: src/ch17-03-more-futures.md:282
msgid ""
"We can also compose futures together to create new patterns. For example, we "
"can build a `timeout` function with async building blocks we already have. "
"When we’re done, the result will be another building block we could use to "
"create still more async abstractions."
msgstr ""

#: src/ch17-03-more-futures.md:287
msgid ""
"Listing 17-18 shows how we would expect this `timeout` to work with a slow "
"future."
msgstr ""

#: src/ch17-03-more-futures.md:301 src/ch17-03-more-futures.md:343
#: src/ch17-03-more-futures.md:388
msgid "\"Finally finished\""
msgstr ""

#: src/ch17-03-more-futures.md:305 src/ch17-03-more-futures.md:347
#: src/ch17-03-more-futures.md:392
msgid "\"Succeeded with '{message}'\""
msgstr ""

#: src/ch17-03-more-futures.md:307 src/ch17-03-more-futures.md:349
#: src/ch17-03-more-futures.md:394
msgid "\"Failed after {} seconds\""
msgstr ""

#: src/ch17-03-more-futures.md:316
msgid ""
"Let’s implement this! To begin, let’s think about the API for `timeout`:"
msgstr ""

#: src/ch17-03-more-futures.md:318
msgid "It needs to be an async function itself so we can await it."
msgstr ""

#: src/ch17-03-more-futures.md:319
msgid ""
"Its first parameter should be a future to run. We can make it generic to "
"allow it to work with any future."
msgstr ""

#: src/ch17-03-more-futures.md:321
msgid ""
"Its second parameter will be the maximum time to wait. If we use a "
"`Duration`, that will make it easy to pass along to `trpl::sleep`."
msgstr ""

#: src/ch17-03-more-futures.md:323
msgid ""
"It should return a `Result`. If the future completes successfully, the "
"`Result` will be `Ok` with the value produced by the future. If the timeout "
"elapses first, the `Result` will be `Err` with the duration that the timeout "
"waited for."
msgstr ""

#: src/ch17-03-more-futures.md:328
msgid "Listing 17-19 shows this declaration."
msgstr ""

#: src/ch17-03-more-futures.md:359
msgid "// Here is where our implementation will go!\n"
msgstr ""

#: src/ch17-03-more-futures.md:365
msgid ""
"That satisfies our goals for the types. Now let’s think about the _behavior_ "
"we need: we want to race the future passed in against the duration. We can "
"use `trpl::sleep` to make a timer future from the duration, and use `trpl::"
"select` to run that timer with the future the caller passes in."
msgstr ""

#: src/ch17-03-more-futures.md:370
msgid ""
"In Listing 17-20, we implement `timeout` by matching on the result of "
"awaiting `trpl::select`."
msgstr ""

#: src/ch17-03-more-futures.md:381
msgid "// --snip--\n"
msgstr ""

#: src/ch17-03-more-futures.md:413
msgid ""
"The implementation of `trpl::select` is not fair: it always polls arguments "
"in the order in which they are passed (other `select` implementations will "
"randomly choose which argument to poll first). Thus, we pass `future_to_try` "
"to `select` first so it gets a chance to complete even if `max_time` is a "
"very short duration. If `future_to_try` finishes first, `select` will return "
"`Left` with the output from `future_to_try`. If `timer` finishes first, "
"`select` will return `Right` with the timer’s output of `()`."
msgstr ""

#: src/ch17-03-more-futures.md:421
msgid ""
"If the `future_to_try` succeeds and we get a `Left(output)`, we return "
"`Ok(output)`. If the sleep timer elapses instead and we get a `Right(())`, "
"we ignore the `()` with `_` and return `Err(max_time)` instead."
msgstr ""

#: src/ch17-03-more-futures.md:425
msgid ""
"With that, we have a working `timeout` built out of two other async helpers. "
"If we run our code, it will print the failure mode after the timeout:"
msgstr ""

#: src/ch17-03-more-futures.md:432
msgid ""
"Because futures compose with other futures, you can build really powerful "
"tools using smaller async building blocks. For example, you can use this "
"same approach to combine timeouts with retries, and in turn use those with "
"operations such as network calls (such as those in Listing 17-5)."
msgstr ""

#: src/ch17-03-more-futures.md:437
msgid ""
"In practice, you’ll usually work directly with `async` and `await`, and "
"secondarily with functions such as `select` and macros such as the `join!` "
"macro to control how the outermost futures are executed."
msgstr ""

#: src/ch17-03-more-futures.md:441
msgid ""
"We’ve now seen a number of ways to work with multiple futures at the same "
"time. Up next, we’ll look at how we can work with multiple futures in a "
"sequence over time with _streams_."
msgstr ""
