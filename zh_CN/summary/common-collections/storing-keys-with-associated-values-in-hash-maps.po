msgid ""
msgstr ""
"Project-Id-Version: The Rust Programming Language\n"
"POT-Creation-Date: 2025-11-29T06:49:36Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/ch08-03-hash-maps.md:1
msgid "Storing Keys with Associated Values in Hash Maps"
msgstr ""

#: src/ch08-03-hash-maps.md:3
msgid ""
"The last of our common collections is the hash map. The type `HashMap<K, V>` "
"stores a mapping of keys of type `K` to values of type `V` using a _hashing "
"function_, which determines how it places these keys and values into memory. "
"Many programming languages support this kind of data structure, but they "
"often use a different name, such as _hash_, _map_, _object_, _hash table_, "
"_dictionary_, or _associative array_, just to name a few."
msgstr ""

#: src/ch08-03-hash-maps.md:10
msgid ""
"Hash maps are useful when you want to look up data not by using an index, as "
"you can with vectors, but by using a key that can be of any type. For "
"example, in a game, you could keep track of each team’s score in a hash map "
"in which each key is a team’s name and the values are each team’s score. "
"Given a team name, you can retrieve its score."
msgstr ""

#: src/ch08-03-hash-maps.md:16
msgid ""
"We’ll go over the basic API of hash maps in this section, but many more "
"goodies are hiding in the functions defined on `HashMap<K, V>` by the "
"standard library. As always, check the standard library documentation for "
"more information."
msgstr ""

#: src/ch08-03-hash-maps.md:20
msgid "Creating a New Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:22
msgid ""
"One way to create an empty hash map is to use `new` and to add elements with "
"`insert`. In Listing 8-20, we’re keeping track of the scores of two teams "
"whose names are _Blue_ and _Yellow_. The Blue team starts with 10 points, "
"and the Yellow team starts with 50."
msgstr ""

#: src/ch08-03-hash-maps.md:35 src/ch08-03-hash-maps.md:66
#: src/ch08-03-hash-maps.md:69 src/ch08-03-hash-maps.md:92
#: src/ch08-03-hash-maps.md:125 src/ch08-03-hash-maps.md:175
#: src/ch08-03-hash-maps.md:176 src/ch08-03-hash-maps.md:212
#: src/ch08-03-hash-maps.md:215
msgid "\"Blue\""
msgstr ""

#: src/ch08-03-hash-maps.md:36 src/ch08-03-hash-maps.md:67
#: src/ch08-03-hash-maps.md:93 src/ch08-03-hash-maps.md:214
msgid "\"Yellow\""
msgstr ""

#: src/ch08-03-hash-maps.md:42
msgid ""
"Note that we need to first `use` the `HashMap` from the collections portion "
"of the standard library. Of our three common collections, this one is the "
"least often used, so it’s not included in the features brought into scope "
"automatically in the prelude. Hash maps also have less support from the "
"standard library; there’s no built-in macro to construct them, for example."
msgstr ""

#: src/ch08-03-hash-maps.md:48
msgid ""
"Just like vectors, hash maps store their data on the heap. This `HashMap` "
"has keys of type `String` and values of type `i32`. Like vectors, hash maps "
"are homogeneous: All of the keys must have the same type, and all of the "
"values must have the same type."
msgstr ""

#: src/ch08-03-hash-maps.md:53
msgid "Accessing Values in a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:55
msgid ""
"We can get a value out of the hash map by providing its key to the `get` "
"method, as shown in Listing 8-21."
msgstr ""

#: src/ch08-03-hash-maps.md:76
msgid ""
"Here, `score` will have the value that’s associated with the Blue team, and "
"the result will be `10`. The `get` method returns an `Option<&V>`; if "
"there’s no value for that key in the hash map, `get` will return `None`. "
"This program handles the `Option` by calling `copied` to get an "
"`Option<i32>` rather than an `Option<&i32>`, then `unwrap_or` to set `score` "
"to zero if `scores` doesn’t have an entry for the key."
msgstr ""

#: src/ch08-03-hash-maps.md:83
msgid ""
"We can iterate over each key-value pair in a hash map in a similar manner as "
"we do with vectors, using a `for` loop:"
msgstr ""

#: src/ch08-03-hash-maps.md:96
msgid "\"{key}: {value}\""
msgstr ""

#: src/ch08-03-hash-maps.md:101
msgid "This code will print each pair in an arbitrary order:"
msgstr ""

#: src/ch08-03-hash-maps.md:110
msgid "<a id=\"hash-maps-and-ownership\"></a>"
msgstr ""

#: src/ch08-03-hash-maps.md:112
msgid "Managing Ownership in Hash Maps"
msgstr ""

#: src/ch08-03-hash-maps.md:114
msgid ""
"For types that implement the `Copy` trait, like `i32`, the values are copied "
"into the hash map. For owned values like `String`, the values will be moved "
"and the hash map will be the owner of those values, as demonstrated in "
"Listing 8-22."
msgstr ""

#: src/ch08-03-hash-maps.md:124
msgid "\"Favorite color\""
msgstr ""

#: src/ch08-03-hash-maps.md:129
msgid ""
"// field_name and field_value are invalid at this point, try using them and\n"
"    // see what compiler error you get!\n"
msgstr ""

#: src/ch08-03-hash-maps.md:136
msgid ""
"We aren’t able to use the variables `field_name` and `field_value` after "
"they’ve been moved into the hash map with the call to `insert`."
msgstr ""

#: src/ch08-03-hash-maps.md:139
msgid ""
"If we insert references to values into the hash map, the values won’t be "
"moved into the hash map. The values that the references point to must be "
"valid for at least as long as the hash map is valid. We’ll talk more about "
"these issues in [“Validating References with Lifetimes”](ch10-03-lifetime-"
"syntax.html#validating-references-with-lifetimes)<!-- ignore --> in Chapter "
"10."
msgstr ""

#: src/ch08-03-hash-maps.md:145
msgid "Updating a Hash Map"
msgstr ""

#: src/ch08-03-hash-maps.md:147
msgid ""
"Although the number of key and value pairs is growable, each unique key can "
"only have one value associated with it at a time (but not vice versa: For "
"example, both the Blue team and the Yellow team could have the value `10` "
"stored in the `scores` hash map)."
msgstr ""

#: src/ch08-03-hash-maps.md:152
msgid ""
"When you want to change the data in a hash map, you have to decide how to "
"handle the case when a key already has a value assigned. You could replace "
"the old value with the new value, completely disregarding the old value. You "
"could keep the old value and ignore the new value, only adding the new value "
"if the key _doesn’t_ already have a value. Or you could combine the old "
"value and the new value. Let’s look at how to do each of these!"
msgstr ""

#: src/ch08-03-hash-maps.md:159
msgid "Overwriting a Value"
msgstr ""

#: src/ch08-03-hash-maps.md:161
msgid ""
"If we insert a key and a value into a hash map and then insert that same key "
"with a different value, the value associated with that key will be replaced. "
"Even though the code in Listing 8-23 calls `insert` twice, the hash map will "
"only contain one key-value pair because we’re inserting the value for the "
"Blue team’s key both times."
msgstr ""

#: src/ch08-03-hash-maps.md:178 src/ch08-03-hash-maps.md:217
msgid "\"{scores:?}\""
msgstr ""

#: src/ch08-03-hash-maps.md:184
msgid ""
"This code will print `{\"Blue\": 25}`. The original value of `10` has been "
"overwritten."
msgstr ""

#: src/ch08-03-hash-maps.md:189
msgid "<a id=\"only-inserting-a-value-if-the-key-has-no-value\"></a>"
msgstr ""

#: src/ch08-03-hash-maps.md:191
msgid "Adding a Key and Value Only If a Key Isn’t Present"
msgstr ""

#: src/ch08-03-hash-maps.md:193
msgid ""
"It’s common to check whether a particular key already exists in the hash map "
"with a value and then to take the following actions: If the key does exist "
"in the hash map, the existing value should remain the way it is; if the key "
"doesn’t exist, insert it and a value for it."
msgstr ""

#: src/ch08-03-hash-maps.md:198
msgid ""
"Hash maps have a special API for this called `entry` that takes the key you "
"want to check as a parameter. The return value of the `entry` method is an "
"enum called `Entry` that represents a value that might or might not exist. "
"Let’s say we want to check whether the key for the Yellow team has a value "
"associated with it. If it doesn’t, we want to insert the value `50`, and the "
"same for the Blue team. Using the `entry` API, the code looks like Listing "
"8-24."
msgstr ""

#: src/ch08-03-hash-maps.md:223
msgid ""
"The `or_insert` method on `Entry` is defined to return a mutable reference "
"to the value for the corresponding `Entry` key if that key exists, and if "
"not, it inserts the parameter as the new value for this key and returns a "
"mutable reference to the new value. This technique is much cleaner than "
"writing the logic ourselves and, in addition, plays more nicely with the "
"borrow checker."
msgstr ""

#: src/ch08-03-hash-maps.md:229
msgid ""
"Running the code in Listing 8-24 will print `{\"Yellow\": 50, \"Blue\": 10}"
"`. The first call to `entry` will insert the key for the Yellow team with "
"the value `50` because the Yellow team doesn’t have a value already. The "
"second call to `entry` will not change the hash map, because the Blue team "
"already has the value `10`."
msgstr ""

#: src/ch08-03-hash-maps.md:235
msgid "Updating a Value Based on the Old Value"
msgstr ""

#: src/ch08-03-hash-maps.md:237
msgid ""
"Another common use case for hash maps is to look up a key’s value and then "
"update it based on the old value. For instance, Listing 8-25 shows code that "
"counts how many times each word appears in some text. We use a hash map with "
"the words as keys and increment the value to keep track of how many times "
"we’ve seen that word. If it’s the first time we’ve seen a word, we’ll first "
"insert the value `0`."
msgstr ""

#: src/ch08-03-hash-maps.md:250
msgid "\"hello world wonderful world\""
msgstr ""

#: src/ch08-03-hash-maps.md:259
msgid "\"{map:?}\""
msgstr ""

#: src/ch08-03-hash-maps.md:265
msgid ""
"This code will print `{\"world\": 2, \"hello\": 1, \"wonderful\": 1}`. You "
"might see the same key-value pairs printed in a different order: Recall from "
"[“Accessing Values in a Hash Map”](#accessing-values-in-a-hash-map)<!-- "
"ignore --> that iterating over a hash map happens in an arbitrary order."
msgstr ""

#: src/ch08-03-hash-maps.md:270
msgid ""
"The `split_whitespace` method returns an iterator over subslices, separated "
"by whitespace, of the value in `text`. The `or_insert` method returns a "
"mutable reference (`&mut V`) to the value for the specified key. Here, we "
"store that mutable reference in the `count` variable, so in order to assign "
"to that value, we must first dereference `count` using the asterisk (`*`). "
"The mutable reference goes out of scope at the end of the `for` loop, so all "
"of these changes are safe and allowed by the borrowing rules."
msgstr ""

#: src/ch08-03-hash-maps.md:278
msgid "Hashing Functions"
msgstr ""

#: src/ch08-03-hash-maps.md:280
msgid ""
"By default, `HashMap` uses a hashing function called _SipHash_ that can "
"provide resistance to denial-of-service (DoS) attacks involving hash "
"tables[^siphash]<!-- ignore -->. This is not the fastest hashing algorithm "
"available, but the trade-off for better security that comes with the drop in "
"performance is worth it. If you profile your code and find that the default "
"hash function is too slow for your purposes, you can switch to another "
"function by specifying a different hasher. A _hasher_ is a type that "
"implements the `BuildHasher` trait. We’ll talk about traits and how to "
"implement them in [Chapter 10](ch10-02-traits.html)<!-- ignore -->. You "
"don’t necessarily have to implement your own hasher from scratch; [crates.io]"
"(https://crates.io/)<!-- ignore --> has libraries shared by other Rust users "
"that provide hashers implementing many common hashing algorithms."
msgstr ""

#: src/ch08-03-hash-maps.md:293
msgid ""
"[https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/"
"SipHash)"
msgstr ""

#: src/ch08-03-hash-maps.md:295
msgid "Summary"
msgstr ""

#: src/ch08-03-hash-maps.md:297
msgid ""
"Vectors, strings, and hash maps will provide a large amount of functionality "
"necessary in programs when you need to store, access, and modify data. Here "
"are some exercises you should now be equipped to solve:"
msgstr ""

#: src/ch08-03-hash-maps.md:301
msgid ""
"Given a list of integers, use a vector and return the median (when sorted, "
"the value in the middle position) and mode (the value that occurs most "
"often; a hash map will be helpful here) of the list."
msgstr ""

#: src/ch08-03-hash-maps.md:304
msgid ""
"Convert strings to Pig Latin. The first consonant of each word is moved to "
"the end of the word and _ay_ is added, so _first_ becomes _irst-fay_. Words "
"that start with a vowel have _hay_ added to the end instead (_apple_ becomes "
"_apple-hay_). Keep in mind the details about UTF-8 encoding!"
msgstr ""

#: src/ch08-03-hash-maps.md:308
msgid ""
"Using a hash map and vectors, create a text interface to allow a user to add "
"employee names to a department in a company; for example, “Add Sally to "
"Engineering” or “Add Amir to Sales.” Then, let the user retrieve a list of "
"all people in a department or all people in the company by department, "
"sorted alphabetically."
msgstr ""

#: src/ch08-03-hash-maps.md:314
msgid ""
"The standard library API documentation describes methods that vectors, "
"strings, and hash maps have that will be helpful for these exercises!"
msgstr ""

#: src/ch08-03-hash-maps.md:317
msgid ""
"We’re getting into more complex programs in which operations can fail, so "
"it’s a perfect time to discuss error handling. We’ll do that next!"
msgstr ""
